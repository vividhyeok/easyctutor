# 0장. 이 사이트를 만든 이유

## 0-1. 안녕하세요

안녕하세요 여러분.

이 사이트는 제가 **처음 C 언어를 공부할 때** 느꼈던 어려움 때문에 만들었어요.

코드를 따라 치긴 했는데,

“내가 지금 뭘 한 거지?” 싶은 순간이 자주 왔거든요.

튜터링을 하면서도 비슷한 장면을 정말 많이 봤어요.

그래서 목표를 딱 하나로 잡았어요.

**처음 시작하는 사람이 덜 무섭게, 그래도 직접 코드를 짤 수 있게** 만들자고요.

---

## 0-2. 이 사이트는 이렇게 진행돼요

설명은 길게 늘어놓지 않을 거예요.

대신 흐름은 이렇게 갈 거예요.

> - **코드를 먼저 봐요.**
> - “여기서 헷갈리겠다” 싶은 부분만 딱 짚어요.
> - 그 부분은 **시각화로** 한 번 더 잡아요.
> - 다시 코드로 돌아와요.

시각화는 예쁘게 꾸미려는 목적이 아니에요.

**말로만 하면 끊기는 이해를 이어 붙이려고** 넣는 거예요.

---

## 0-3. 이 사이트에서의 목표

이 사이트의 목표는 하나예요.

> **혼자서 C 코드를 짤 수 있게 되는 것.**
> 

설명을 완벽히 이해하고 넘어가려고 하면

초반에 지치기 쉬워요.

여기서는 일단 작게라도

**직접 짜는 감각**을 만드는 쪽으로 갈게요.

---

## 0-4. 이렇게 공부하면 제일 편해요

제가 추천하는 방법은 간단해요.

> - **IDE를 하나 켜두고**
> - 이 웹사이트를 **순서대로 넘겨가면서**
> - 코드는 **한 글자씩 직접** 따라 치고 넘어가기

오타가 나도 괜찮아요.

오히려 오타가 나면 “어디서 틀렸는지”를 보게 돼서 도움이 돼요.

---

## 0-5. 예시는 실생활 말고, 코딩 상황으로만

실생활 비유는 일부러 쓰지 않을 거예요.

오히려 헷갈릴 수 있거든요.

대신 이런 식의 **코딩 상황**만 예시로 쓸 거예요.

> - 입력값이 여러 개 들어온다
> - 같은 일을 반복해서 처리해야 한다
> - 여러 값을 모아서 계산해야 한다

---

## 0-6. 마지막으로

처음엔 누구나 막혀요.

그건 이상한 게 아니라 자연스러운 거예요.

여기는 그 막히는 구간을

최대한 짧게 만들려고 만든 곳이에요.

같이 천천히 가봐요.

---

# 1장. C 프로그램은 어떻게 실행되는가

## 1-1. 이 장에서 딱 하나만 잡고 가요

C는 코드를 적고 끝이 아니에요.

코드를 적고, **한 번 만든 다음에**, 실행해요.

그 “만드는 과정”이 **컴파일**이에요.

---

## 1-2. C가 돌아가는 순서

C는 보통 이렇게 움직여요.

> - 코드를 적어요 (`.c`)
> - 컴퓨터가 실행할 수 있게 **만들어요** (컴파일)
> - 만들어진 걸 **실행**해요

이 흐름만 잡혀도,

“왜 안 되지?” 할 때 어디를 봐야 하는지 감이 빨리 와요.

---

## 1-3. `main`은 시작점이에요

컴퓨터 입장에서는 파일을 열었을 때

“어디부터 시작하지?”가 애매해요.

그래서 C 프로그램은 보통 `main()`을 시작점으로 정해요.

`main()` 안에 있는 코드가 실행된다고 보면 돼요.

---

## 1-4. 실행 흐름은 기본적으로 “위에서 아래로”

일단은 이렇게 생각하면 편해요.

- `main()` 안에 적힌 코드는
- 위에서 아래로 한 줄씩 실행돼요

나중에 조건문이랑 반복문을 배우면

흐름이 갈라지고 돌아가긴 하는데,

출발은 항상 이 느낌이에요.

---

## 1-5. 에러는 두 종류로만 나누면 편해요

에러가 나오면 일단 이렇게만 나누면 돼요.

- **컴파일 에러**: 실행 파일이 아예 안 만들어져요.
    
    보통 문법, 철자, 괄호 같은 게 원인이에요.
    
- **실행 에러(또는 결과 이상)**: 실행은 되는데 중간에 터지거나 결과가 이상해요.
    
    보통 문법보다 “내가 짠 로직”이 원인인 경우가 많아요.
    

이렇게만 구분해도 문제 해결이 훨씬 쉬워져요.

---

## 1-6. 첫 번째 프로그램

아래 코드는 **복사하지 말고**, 한 글자씩 직접 따라 쳐보세요.

오타가 나도 괜찮아요. 에러를 보는 게 실력이에요.

```c
#include <stdio.h>

int main(void) {
    printf("Hello, World!\n");
    return 0;
}

```

여기서 지금 중요한 건 딱 세 개예요.

> - `main()` 안이 실행된다
> - `printf`는 화면에 출력한다
> - `\n`은 줄바꿈이다

---

## 1-7. 미션

- 위 코드를 **직접 입력해서** 실행해요.
- 화면에 `Hello, World!`가 뜨면 성공이에요.

---

## 1-8. 다음 장

다음 장부터는

값을 저장하는 방법, 즉 **변수**로 들어갈 거예요.

---

# 2장. 값과 변수 — 컴퓨터에게 기억을 시키는 방법

## 2-1. 값이랑 변수는 다르게 생겼어요

코드에 나오는 `10` 같은 건 그냥 **값**이에요.

근데 `x` 같은 건 값이 아니고, **이름**이에요.

변수는 한 줄로 말하면 이거예요.

> 변수는 **값이 들어갈 자리**에 붙는 이름표예요.
> 

값은 왔다 갔다 할 수 있는데,

변수는 그 값을 **어디에 저장할지**를 정해줘요.

---

## 2-2. 변수 선언은 “자리 만들기”예요

변수를 쓰려면 일단 자리를 만들어야 해요.

```c
int x;

```

이건 “x라는 변수를 만들었다”라기보다,

“정수 하나 들어갈 자리를 하나 만들고, 그 자리에 x라는 이름을 붙였다”에 가까워요.

---

## 2-3. 변수에 값 넣기

자리를 만들었으면, 이제 값을 넣어요.

```c
x = 3;

```

이건 “x랑 3이 같다”가 아니에요.

“3을 계산해서 x에 **저장**해”예요.

그래서 이런 것도 가능해요.

```c
x = x + 1;

```

오른쪽을 먼저 계산하고, 그 결과를 다시 x에 넣는 거예요.

---

## 2-4. 선언하자마자 값 넣는 게 편해요

초반에는 보통 이렇게 쓰는 게 제일 편해요.

```c
int x = 3;

```

선언하고 나서 값 넣는 걸 한 번에 하는 거예요.

C는 어떤 경우에는,

값을 안 넣고 출력하면 결과가 이상하게 나올 수 있어요.

그래서 초반엔 “선언 = 초기화” 습관이 도움 돼요.

---

## 2-5. 자료형은 “어떤 값인지” 알려주는 거예요

`int`는 정수라는 뜻이에요.

즉, x에는 정수만 들어갈 거라고 컴퓨터에게 말해주는 거예요.

지금 단계에서는 이것만 구분하면 충분해요.

- `int` : 정수
- `double` : 실수(소수점 있는 값)
- `char` : 문자 한 글자

자료형은 “정확한 크기”까지 파고들면 복잡해지는데,

여기서는 일단 “종류”만 잡고 갈게요.

---

## 2-6. 작은 예시를 직접 쳐볼게요

복사하지 말고, 직접 쳐보세요.

```c
#include <stdio.h>

int main(void) {
    int x = 3;
    int y = 5;

    printf("%d\n", x);
    printf("%d\n", y);
    printf("%d\n", x + y);

    return 0;
}

```

여기서 보는 포인트는 딱 세 개예요.

> - 변수에 값을 저장할 수 있다
> - `printf("%d", ...)`로 정수를 출력할 수 있다
> - 변수로 계산할 수 있다

---

## 2-7. 미션

아래 두 개를 해보면 돼요.

- `x` 값을 10으로 바꿔서 실행해보기
- `x + y` 말고 `x * y`도 출력해보기

---

## 2-8. 다음 장

다음 장에서는

값을 더 다양하게 **계산하고**, **저장하는 방식**을 배워요.

연산자랑 대입 이야기로 가봅시다.

---

# 3장. 계산과 대입 — 값으로 일 시키기

## 3-1. `=`는 “같다”가 아니라 “넣는다”예요

C에서 `=`는 수학의 “=”이 아니에요.

```c
x = 3;

```

이건 “x와 3은 같다”가 아니라,

“3을 x에 **저장해**”예요.

그래서 이런 것도 가능해요.

```c
x = x + 1;

```

오른쪽을 먼저 계산하고,

그 결과를 다시 x에 넣는 거예요.

---

## 3-2. 기본 연산은 계산기처럼 써요

자주 쓰는 연산은 이 정도예요.

- 더하기 `+`
- 빼기 `-`
- 곱하기 `*`
- 나누기 `/`
- 나머지 `%`

`%`는 생각보다 많이 써요.

예를 들어 5를 2로 나누면:

> **5 / 2 = 2** (몫)  
> **5 % 2 = 1** (나머지)

“짝수/홀수”, “몇 개씩 묶기” 같은 데서 자주 나와요.

---

## 3-3. 나누기는 조심해야 해요

정수끼리 나누면 결과도 정수로 나올 때가 많아요.

예를 들어 `5 / 2`는

우리가 기대하는 2.5가 아니라, **2**가 나올 수 있어요.

지금은 이유까지 깊게 안 들어가도 돼요.

대신 이렇게만 기억해요.

> 정수 나누기는 소수점이 잘릴 수 있어요.
> 

---

## 3-4. “계산 → 저장” 흐름이 핵심이에요

C 코드는 대부분 이 패턴이에요.

> - 오른쪽에서 계산하고
> - 왼쪽에 저장한다

예를 들면 이런 거요.

```c
sum = a + b;

```

이 감각만 익숙해지면,

코드 읽는 속도가 확 올라가요.

---

## 3-5. 줄임말 연산(복합 대입)

자주 쓰는 패턴은 줄여 쓸 수 있어요.

```c
x = x + 1;

```

이걸 이렇게 줄여요.

```c
x += 1;

```

다른 것도 비슷해요.

- `x -= 1;`
- `x *= 2;`
- `x /= 3;`

처음엔 긴 버전으로 써도 괜찮아요.

익숙해지면 줄인 게 더 읽기 편해져요.

---

## 3-6. 증가/감소도 많이 써요

이건 나중에 반복문에서 특히 많이 보게 돼요.

```c
x++;
x--;

```

각각 `x += 1`, `x -= 1` 같은 느낌이에요.

---

## 3-7. 직접 쳐볼 예시

복사하지 말고, 직접 쳐보세요.

```c
#include <stdio.h>

int main(void) {
    int a = 10;
    int b = 3;

    printf("%d\n", a + b);
    printf("%d\n", a - b);
    printf("%d\n", a * b);
    printf("%d\n", a / b);
    printf("%d\n", a % b);

    a += 5;
    printf("%d\n", a);

    a++;
    printf("%d\n", a);

    return 0;
}

```

여기서 보는 포인트는 이거예요.

> - 연산 결과를 바로 출력할 수 있다
> - `/`랑 `%`는 결과가 다르다
> - `+=`, `++` 같은 줄임말이 있다

---

## 3-8. 미션

아래 두 개만 해보면 돼요.

- `a`를 11로 바꾸고 `a % b`가 어떻게 바뀌는지 보기
- `a / b` 결과가 왜 정수처럼 나오는지 느낌 잡기 (소수점이 사라짐)

---

## 3-9. 다음 장

다음 장에서는

이제 화면에 출력하는 걸 좀 더 제대로 써볼 거예요.

`printf`를 더 익숙하게 만들고,

입력(`scanf`)도 살짝 건드릴 거예요.

---

# 4장. 출력과 입력 — 결과를 눈으로 확인하기

## 4-1. 출력은 “보여주기”가 아니라 “확인하기”예요

C 공부할 때 제일 중요한 습관이 하나 있어요.

> **중간중간 출력으로 확인하기.**
> 

코드가 길어질수록

“내가 생각한 대로 돌아가고 있나?”가 중요해져요.

그때 `printf`가 가장 쉬운 확인 도구예요.

---

## 4-2. `printf`는 화면에 찍는 함수예요

가장 기본은 이거예요.

```c
printf("Hello\n");

```

따옴표 안의 문장을 그대로 출력해요.

`\n`은 줄바꿈이에요.

---

## 4-3. 변수도 같이 출력할 수 있어요

문제는 여기서부터예요.

문장 말고 “변수 값”을 출력하고 싶어지죠.

그때 쓰는 게 **형식 지정자**예요.

정수는 보통 `%d`를 써요.

```c
int x = 7;
printf("%d\n", x);

```

이 뜻은 딱 이거예요.

> - `%d` 자리에
> - `x` 값을 넣어서 출력해라

---

## 4-4. 자주 쓰는 형식만 딱 기억해요

여기서는 욕심 안 내고 이것만 잡아요.

- `%d` : 정수(`int`)
- `%f` : 실수(`double`)
- `%c` : 문자(`char`)

일단 `%d`만 익숙해져도

문제풀이의 대부분은 커버돼요.

---

## 4-5. 출력이 이상하면 보통 이거예요

`printf`가 이상하면 흔한 원인은 거의 정해져 있어요.

- 자료형이랑 형식이 안 맞음
    - `double`인데 `%d` 쓰기
    - `int`인데 `%f` 쓰기
- 줄바꿈이 없어서 출력이 붙어 보임 (`\n` 빠짐)

이런 건 나중에 실수하면서 익숙해져요.

---

## 4-6. 입력도 받아볼게요 (`scanf`)

이제 숫자를 “내가 정한 값” 말고

사용자한테서 받아오고 싶어지죠.

그때 `scanf`를 써요.

```c
int x;
scanf("%d", &x);

```

여기서 중요한 건 딱 하나예요.

> `scanf`에서는 변수 앞에 `&`가 붙는 경우가 많아요.
> 

왜 그런지는 나중에 포인터에서 제대로 설명할게요.

지금은 “입력 받을 때는 &가 자주 붙는다” 정도로만 두고 갑시다.

---

## 4-7. 직접 쳐볼 예시

복사하지 말고 직접 쳐보세요.

```c
#include <stdio.h>

int main(void) {
    int a;
    int b;

    scanf("%d %d", &a, &b);

    printf("%d\n", a + b);
    printf("%d\n", a - b);
    printf("%d\n", a * b);

    return 0;
}

```

포인트는 이거예요.

> - 입력을 받으면 "내 코드가 더 재밌어짐"
> - 입력값에 따라 결과가 바뀐다
> - `scanf`는 `%d`랑 `&변수`가 세트처럼 따라온다

---

## 4-8. 미션

아래를 해보면 돼요.

- 입력을 `3 5`로 넣고 결과 확인하기
- 입력을 `10 2`로 바꾸고 결과 확인하기
- `printf`에 `a`랑 `b`를 따로 찍어서, 내가 입력한 값이 맞는지도 확인하기

---

## 4-9. 다음 장

다음 장에서는

이제 코드가 “상황에 따라 다르게 행동”하게 만들 거예요.

---

# 5장. 조건문 — 상황에 따라 다르게 행동하기

## 5-1. 조건문은 “질문하고 갈림길 타기”예요

지금까지 코드는 늘 한 방향으로만 갔어요.

위에서 아래로 쭉 실행되는 느낌이었죠.

근데 이제부터는 이렇게 하고 싶어져요.

> - 점수가 60 이상이면 “합격”
> - 아니면 “불합격”
> - 음수가 들어오면 “잘못된 입력”

이럴 때 쓰는 게 조건문이에요.

> `if`는 컴퓨터에게 **참/거짓 질문을 던지는 문법**이에요.
> 

---

## 5-2. `if` 기본 형태

가장 기본은 이거예요.

```c
if (조건) {
    실행할 코드
}

```

조건이 참이면 `{}` 안이 실행되고,

거짓이면 그냥 건너뛰어요.

---

## 5-3. `else`는 “아니면 이거 해”

조건이 거짓일 때도 뭔가 하고 싶으면 `else`를 붙여요.

```c
if (조건) {
    A
} else {
    B
}

```

> - 조건이 참이면 A
> - 조건이 거짓이면 B

이렇게 두 갈래로 나뉘는 게 `if-else`예요.

---

## 5-4. 조건은 보통 “비교”예요

조건문에서 많이 쓰는 건 비교예요.

- `>` 크다
- `<` 작다
- `>=` 크거나 같다
- `<=` 작거나 같다
- `==` 같다
- `!=` 다르다

여기서 제일 많이 하는 실수는 이거예요.

> `=`랑 `==` 헷갈리기
> 
- `=` : 저장(대입)
- `==` : 같은지 비교

조건문에서는 비교가 필요하니까 `==`를 써야 해요.

---

## 5-5. 조건을 여러 개 묶을 수도 있어요

“그리고”, “또는” 같은 말도 코드로 표현할 수 있어요.

- `&&` : 둘 다 참이어야 참 (그리고)
- `||` : 둘 중 하나만 참이어도 참 (또는)

예를 들면 이런 느낌이에요.

- 0 이상이고 100 이하인지 확인하기
- 점수가 90 이상이거나 출석이 만점인지 확인하기

지금은 `&&`, `||`가 있다는 것만 익숙해져도 충분해요.

---

## 5-6. 직접 쳐볼 예시

복사하지 말고 직접 쳐보세요.

```c
#include <stdio.h>

int main(void) {
    int score;
    scanf("%d", &score);

    if (score >= 60) {
        printf("PASS\n");
    } else {
        printf("FAIL\n");
    }

    return 0;
}

```

입력값을 바꿔가면서 실행해보면

조건문 감각이 바로 와요.

- 60 넣기
- 59 넣기
- 100 넣기
- 0 넣기

---

## 5-7. 자주 터지는 포인트

조건문에서 자주 망하는 건 딱 두 개예요.

- `=`를 써버림 (원래 `==`를 써야 했는데)
- 중괄호 `{}`를 빼먹거나 위치를 헷갈림

에러 나면 그냥 그거부터 찾아보면 돼요.

---

## 5-8. 미션

아래 두 개를 해보면 돼요.

- 점수가 0~100이 아니면 `"INVALID"` 출력하기
- 90 이상이면 `"A"`, 80 이상이면 `"B"`, 나머지는 `"C"` 출력하기
    
    (힌트: `else if`를 쓰면 돼요)
    

---

## 5-9. 다음 장

다음 장에서는

같은 일을 여러 번 시키는 방법을 배워요.

---

# 6장. 반복문 — 같은 일을 여러 번 시키기

## 6-1. 반복문은 “한 번 만든 규칙을 여러 번 돌리는 것”이에요

코드 짜다 보면 이런 순간이 와요.

> - 같은 걸 10번 출력하고 싶다
> - 숫자 1부터 100까지 더하고 싶다
> - 입력을 여러 번 받아서 처리하고 싶다

이때 코드를 10줄, 100줄 쓰면 너무 힘들죠.

그래서 반복문이 필요해요.

반복문은 **같은 패턴을 여러 번 실행**하는 문법이에요.


---

## 6-2. `for`문은 반복의 기본형이에요

입문 단계에서는 `for`가 제일 많이 쓰여요.

모양이 이렇게 생겼어요.

```c
for (시작; 조건; 변화) {
    실행할 코드
}

```

이걸 말로 풀면 이 느낌이에요.

> - 시작: 어디서부터 시작할지
> - 조건: 언제까지 할지
> - 변화: 한 번 돌 때마다 뭘 바꿀지

---

## 6-3. 가장 많이 쓰는 패턴: 0부터 n-1까지

C에서는 이 패턴이 거의 표준이에요.

**👇 아래 `실행` 버튼을 누르면, `i`가 변하는 과정을 볼 수 있어요.**

<loopbasicviz />

출력은 이렇게 돼요.

- 0
- 1
- 2
- 3
- 4

여기서 중요한 감각은 이거예요.

> - `i`는 반복 횟수를 세는 번호표 같은 거예요
> - `i < 5`라서 5는 안 들어가요
> - 그래서 딱 5번 실행돼요

---

## 6-4. `while`문도 있어요

`while`은 모양이 더 단순해요.

```c
while (조건) {
    실행할 코드
}

```

조건이 참이면 계속 돌고,

거짓이 되면 멈춰요.

---

## 6-5. `for`랑 `while`은 결국 비슷해요

둘 다 “반복”이에요.

차이는 느낌이에요.

- `for` : 몇 번 반복할지 보일 때 편함
- `while` : 언제 끝날지 조건으로 정할 때 편함

입문에서는 `for`를 기본으로 잡고,

`while`은 익숙해지면 같이 쓰면 돼요.

---

## 6-6. 무한 반복은 보통 “조건이 안 바뀌어서” 생겨요

반복문이 안 끝나면 대충 이런 상황이에요.

> - 조건이 계속 참이다
> - 조건을 바꿔야 하는 코드가 없다
> - 변화가 없어서 영원히 돈다

반복문이 안 끝나면

“조건을 바꾸는 줄이 있는지”부터 보면 돼요.

---

## 6-7. 직접 쳐볼 예시 (for)

복사하지 말고 직접 쳐보세요.

```c
#include <stdio.h>

int main(void) {
    int sum = 0;

    for (int i = 1; i <= 10; i++) {
        sum += i;
    }

    printf("%d\n", sum);
    return 0;
}

```

이 코드는 1부터 10까지 더해서 출력해요.

`sum`에 누적하는 느낌이 잡히면 좋아요.

---

## 6-8. 직접 쳐볼 예시 (while)

```c
#include <stdio.h>

int main(void) {
    int x = 5;

    while (x > 0) {
        printf("%d\n", x);
        x--;
    }

    return 0;
}

```

여기서 핵심은 이거예요.

> - 조건: `x > 0`
> - 변화: `x--`
> - 그래서 언젠가 0이 되면서 멈춘다

---

## 6-9. 미션

아래 세 개 중 두 개만 해도 충분해요.

- 1부터 100까지 합 출력하기
- 10부터 1까지 거꾸로 출력하기
- 2의 배수만 20까지 출력하기

---

## 6-10. 다음 장

다음 장에서는

반복문이랑 찰떡인 **배열**로 들어가요.

여기서부터 “문제풀이 느낌”이 확 나기 시작해요.

---

# 7장. 배열 — 여러 개의 값을 한 번에 다루기

## 7-1. 배열이 필요한 순간이 와요

변수는 값 하나를 저장해요.

근데 값이 여러 개면 어떡하죠?

- 점수 5개
- 입력값 10개
- 온도 30개

변수만으로 하면, 이름도 코드도 너무 길어져요.

그래서 배열이 필요해요.

> 배열은 **같은 종류의 값 여러 개를 한 덩어리로** 다루는 방법이에요.
> 

---

## 7-2. 배열은 “칸이 여러 개 있는 묶음”이에요

배열은 이렇게 생각하면 편해요.

> - 같은 자료형의 칸들이
> - 여러 개 붙어 있고
> - 이름 하나로 묶여 있다

그래서 번호로 한 칸씩 골라서 써요.

그 번호가 **인덱스**예요.

---

## 7-3. 인덱스는 0부터 시작해요

배열에서 제일 먼저 헷갈리는 포인트가 이거예요.

> 배열의 첫 칸은 `0`번이에요.
> 
- `arr[0]` : 첫 칸
- `arr[1]` : 두 번째 칸
- `arr[2]` : 세 번째 칸

이건 그냥 C의 약속이에요.

익숙해지면 오히려 이 방식이 더 편해져요.

---

## 7-4. 배열 선언

배열은 이렇게 만들어요.

```c
int arr[5];

```

이 뜻은 이거예요.

> - `int`짜리 칸을
> - 5개 만들어서
> - `arr`이라는 이름으로 묶었다

배열은 “값”이 아니라 “공간”을 먼저 만든다고 생각하면 편해요.

---

## 7-5. 배열에 값 넣고 꺼내기

배열은 `[]`로 칸을 고르고, 거기에 값을 넣어요.

```c
arr[0] = 10;
arr[1] = 20;

```

값을 꺼내는 것도 똑같아요.

```c
printf("%d\n", arr[0]);

```

---

## 7-6. 배열 + 반복문은 한 세트예요

배열을 쓰는 이유는 결국 이거예요.

> 칸이 많아도, **반복문으로 한 번에 처리**할 수 있다.
> 

예를 들어 5칸을 채우는 코드는 이렇게 돼요.

```c
for (int i = 0; i < 5; i++) {
    arr[i] = i * 10;
}

```

여기서 핵심은 간단해요.

- `i`가 0부터 올라가면서
- `arr[i]`가 다음 칸을 가리킨다

---

## 7-7. 배열의 범위는 꼭 지켜야 해요

배열은 편한 대신, 딱 하나는 조심해야 해요.

> 없는 칸을 건드리면 위험해요.
> 

`int arr[5];`면 칸은 5개예요.

쓸 수 있는 인덱스는 `0`부터 `4`까지예요.

- ✅ `arr[0]` ~ `arr[4]`
- ❌ `arr[5]` (없는 칸)

C는 이런 실수를 친절하게 막아주지 않을 때가 많아요.

그래서 배열은 “범위 지키기”가 진짜 중요해요.

---

## 7-8. 직접 쳐볼 예시 (입력 받아서 저장하기)

복사하지 말고 직접 쳐보세요.

```c
#include <stdio.h>

int main(void) {
    int a[5];

    for (int i = 0; i < 5; i++) {
        scanf("%d", &a[i]);
    }

    for (int i = 0; i < 5; i++) {
        printf("%d\n", a[i]);
    }

    return 0;
}

```

이 코드는

- 정수 5개를 입력받아서 배열에 저장하고
- 다시 그대로 출력해요

배열이 “값 여러 개를 저장하는 상자”처럼 느껴지면 성공이에요.

---

## 7-9. 미션

아래 중 두 개만 해도 충분해요.

- 입력받은 5개의 합 구하기
- 입력받은 5개 중 최댓값 구하기
- 입력받은 5개를 거꾸로 출력하기

---

## 7-10. 다음 장

다음 장에서는

배열로 문제를 풀 때 자주 쓰는 패턴을 한 번에 정리할 거예요.

“배열을 쓸 줄 안다”가 아니라,

“배열로 문제를 푼다”로 넘어가요.

---

# 8장. 배열로 문제를 풀어보자

## 8-1. 배열 문제는 결국 이 흐름이에요

배열 문제가 어렵게 느껴지는 이유는

문법이 어려워서가 아니라, 흐름이 안 잡혀서인 경우가 많아요.

배열 문제는 대부분 이 순서로 풀려요.

1. 값을 여러 개 받는다 (배열에 저장)
2. 반복문으로 쭉 훑는다
3. 필요한 값을 만든다 (합/최댓값/개수 같은 거)
4. 출력한다

이 흐름만 익숙해지면, 문제 보는 게 훨씬 편해져요.

---

## 8-2. 패턴 1: 합 구하기

가장 기본 패턴이에요.

- 배열에 입력 받기
- `sum`에 누적하기



포인트는 이거예요.

- `sum`은 0에서 시작
- 한 칸씩 더하면서 커진다
- 마지막에 한 번 출력

**👇 아래 `실행` 버튼을 누르면, 숫자가 `sum`으로 합쳐지는 과정을 볼 수 있어요.**

<arraysumviz />

---

## 8-3. 패턴 2: 최댓값 구하기

최댓값은 “기준값 하나 잡고 시작”이 핵심이에요.



여기서 중요한 감각은 이거예요.

> - `mx`는 “현재까지의 최댓값”
> - 새 값을 보면서 더 크면 바꾼다

**👇 `실행`을 눌러서 왕관(👑)이 씌워진 `mx`가 어떻게 바뀌는지 확인해보세요.**

<arraymaxviz />

---

## 8-4. 패턴 3: 조건에 맞는 개수 세기

이것도 진짜 자주 나와요.

예를 들어 “짝수가 몇 개냐” 같은 문제요.



포인트는 이거예요.

> - `cnt`는 0에서 시작
> - 조건 만족할 때마다 1씩 증가

**👇 짝수(🟢)일 때만 카운트가 올라가는 모습을 확인해보세요.**

<arraycountviz />

---

## 8-5. 패턴 4: 거꾸로 출력하기

배열에서 인덱스 감각 잡기에 좋아요.



여기서 핵심은 이거예요.

> - 마지막 인덱스는 4
> - 4부터 0까지 내려간다

**👇 화살표가 뒤에서 앞으로 이동하며 출력하는 모습을 보세요.**

<arrayreverseviz />

---

## 8-6. 자주 하는 실수 모음

배열 문제에서 가장 많이 터지는 실수들이에요.

- `i < 5`랑 `i <= 5` 헷갈리기
    - `<= 5`는 `a[5]`까지 가버려서 위험해요
- `sum`, `cnt` 같은 변수 초기화 안 하기
    - 0으로 시작해야 하는데 쓰레기 값에서 시작할 수 있어요
- 최댓값을 0으로 시작해버리기
    - 입력이 전부 음수면 망해요
    - 그래서 보통 `mx = a[0]`로 시작해요

---

## 8-7. 미션 (이 장의 끝)

이제 진짜로 “혼자 짜는” 단계예요.

### 미션 A

정수 5개를 입력받아서

**최솟값**을 출력해보세요.

(최댓값 코드에서 `>`를 `<`로 바꾸는 느낌이에요.)

### 미션 B

정수 5개를 입력받아서

- *평균(정수 몫)**을 출력해보세요.

(합을 구한 다음 5로 나누면 돼요.)

### 미션 C

정수 5개 중에서

**3의 배수의 개수**를 출력해보세요.

(`% 3 == 0`)

---

## 8-8. 여기까지 오면 1차 릴리스 목표 달성이에요

여기까지 왔으면, 이미 이걸 할 수 있게 된 거예요.

> - 입력을 받고
> - 배열에 저장하고
> - 반복문으로 처리하고
> - 결과를 출력한다

이게 C 문제풀이의 기본 뼈대예요.

다음 단계는 자연스럽게 이렇게 이어져요.

> - 숫자 여러 개(배열)를 다뤘다
> - 다음은 글자 여러 개(문자열)를 다룬다

하지만 그건 2차 릴리스에서 천천히 가도 돼요.

일단은 여기까지 온 것 자체가 진짜 큰 진전이에요.

---

# 9장. 문자열 — 글자 여러 개를 다루는 방법

## 9-1. 배열을 다뤘다면, 사실 문자열도 반쯤은 끝났어요

8장에서 배열을 했죠.

그럼 문자열은 생각보다 새로울 게 많지 않아요.

왜냐면 C에서 문자열은 보통 이거예요.

> 문자(char)들이 줄줄이 들어있는 배열
> 

즉,

> - 숫자 배열: `int a[5];`
> - 글자 배열: `char s[20];`
> 

“배열의 자료형만 바뀐 것”처럼 시작하면 돼요.

---

## 9-2. 문자 하나는 `char`예요

문자 하나는 이렇게 저장해요.

```c
char c = 'A';

```

여기서 중요한 건 딱 하나예요.

> - 문자는 "A"가 아니라 'A' (작은따옴표)
> 

---

## 9-3. 문자열은 “문자 배열”이에요

문자 여러 개는 이렇게 만들 수 있어요.

```c
char s[20];

```

이건 의미가 이거예요.

> - 글자 20칸짜리 상자를 만들었고
> - 그 상자 이름이 `s`다
> 

---

## 9-4. 문자열이 끝나는 표시가 하나 있어요 (`\0`)

여기서 C가 살짝 특이해요.

문자열은 그냥 글자만 있는 게 아니라

마지막에 **끝 표시**가 하나 붙어요.

그게 `\0` (널 문자)예요.

> - C는 `\0`을 만날 때까지를 문자열로 봐요
> 

이걸 몰라서 초보들이 자주 헤매요.

지금은 이렇게만 기억하면 돼요.

> - 문자열은 마지막에 보이지 않는 끝 표시가 있다.
> 

---

## 9-5. 문자열을 바로 넣는 방법

배열은 원래 한 칸씩 넣었죠.

근데 문자열은 이렇게 한 번에 넣는 방식도 있어요.

```c
char s[] = "hello";

```

여기서 두 가지가 중요해요.

> - 큰따옴표 `"` `"` 는 문자열이에요
> - `hello`에는 끝에 `\0`이 자동으로 붙어요
> 

그래서 `"hello"`는 실제로는 이런 느낌이에요.

> - h e l l o `\0`
> 

---

## 9-6. 문자열 출력은 `%s`예요

정수는 `%d`였죠.

문자열은 `%s`예요.

```c
#include <stdio.h>

int main(void) {
    char s[] = "hello";
    printf("%s\n", s);
    return 0;
}

```

---

## 9-7. 문자열 입력은 일단 가장 단순한 방식만

입력은 여러 방식이 있는데,

초반엔 딱 하나만 잡고 갈게요.

공백 없는 한 단어 입력은 이렇게 받을 수 있어요.

```c
char s[20];
scanf("%s", s);

```

여기서 신기한 점이 하나 있어요.

> - 정수 입력은 `&a`였는데
> - 문자열 입력은 보통 `s`만 써요
> 

이건 지금 이유를 깊게 파지 말고,

그냥 “문자열은 좀 다르다” 정도로만 정리해 둡시다.

---

## 9-8. 직접 쳐볼 예시: 이름을 입력받아 출력하기

복사하지 말고 직접 쳐보세요.

```c
#include <stdio.h>

int main(void) {
    char name[20];

    scanf("%s", name);
    printf("Hello, %s!\n", name);

    return 0;
}

```

입력에 `minhyeok` 같은 걸 넣으면

`Hello, minhyeok!` 이런 식으로 나올 거예요.

---

## 9-9. 문자열에서 제일 많이 하는 실수

문자열에서 자주 터지는 건 딱 두 개예요.

### 9-9-1. 크기 부족

```c
char s[5] = "hello";

```

이건 위험해요.

왜냐면 `"hello"`는 5글자지만

끝 표시 `\0`까지 포함하면 6칸이 필요할 수 있어요.

초반엔 이렇게만 기억해요.

> - 문자열 배열은 “글자 수 + 1” 정도 여유를 주세요
> 

### 9-9-2. 공백 입력이 안 들어감

`scanf("%s")`는 공백에서 끊겨요.

그래서 `hello world`를 넣으면 `hello`만 들어가요.

공백까지 받는 방법은 다음 장에서 더 안전하게 다룰게요.

---

## 9-10. 미션

아래 두 개 중 하나만 해도 충분해요.

- 이름을 입력받아서 `OOO님 환영합니다` 출력하기
- 단어 2개를 입력받아서 각각 한 줄씩 출력하기


힌트:

```c
char a[20], b[20];
scanf("%s %s", a, b);
```

---

## 9-11. 다음 장

다음 장에서는 문자열을 다루는 기본 도구 세 가지를 배울 거예요.

> - 길이 재기 (`strlen`)
> - 복사하기 (`strcpy`)
> - 비교하기 (`strcmp`)
> 

그리고 이 함수들이 내부적으로 어떻게 동작하는지도 볼 거예요.

결국 문자열도 "배열 + 반복문"으로 풀린다는 걸 느낄 수 있을 거예요.

---

# 10장. 문자열 함수 — 쓰는 법 + 직접 구현 감각

## 10-1. 문자열 함수 세 가지만 알면 돼요

이번 장에서는 딱 세 가지만 배울 거예요.

> - `strlen` — 길이 재기
> - `strcpy` — 복사하기
> - `strcmp` — 비교하기
> 

일단 "어떻게 쓰는지"만 익히면 충분해요.

나중에 "어떻게 만드는지"는 자연스럽게 이해될 거예요.

---

## 10-2. 준비: 문자열 함수 쓰려면 `#include <string.h>`

문자열 관련 기본 함수들은 보통 여기 들어있어요.

```c
#include <string.h>

```

---

## 10-3. 길이 재기: `strlen`

`strlen(s)`는 문자열 길이를 돌려줘요.

여기서 “길이”는 중요해요.

> - `\0`은 길이에 포함 안 해요
> - 글자 수만 세요
> 

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char s[] = "hello";

    printf("%d\n", (int)strlen(s));
    return 0;
}

```

---

## 10-4. (참고) `strlen`은 이렇게 동작해요

궁금하면 보고, 아니면 넘어가도 돼요.

문자열 끝은 `\0`이니까,

> - `\0` 만날 때까지 한 칸씩 세면 돼요
> 

```c
int my_strlen(char s[]) {
    int i = 0;
    while (s[i] != '\0') {
        i++;
    }
    return i;
}

```

지금 이해 안 돼도 괜찮아요.

---

## 10-5. 복사하기: `strcpy`

`strcpy(dest, src)`는

> - src 문자열을 dest에 복사해요
> 

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char a[20];
    char b[] = "hello";

    strcpy(a, b);
    printf("%s\n", a);

    return 0;
}

```

여기서 중요한 전제 하나.

> - dest는 충분히 커야 해요
> 

---

## 10-6. (참고) `strcpy`는 이렇게 동작해요

복사는 결국 한 글자씩 옮기는 거예요.

```c
void my_strcpy(char dest[], char src[]) {
    int i = 0;
    while (src[i] != '\0') {
        dest[i] = src[i];
        i++;
    }
    dest[i] = '\0';  // 끝 표시도 복사
}

```

지금은 "아 이런 식이구나" 정도만 보면 돼요.

---

## 10-7. 비교하기: `strcmp`

문자열 비교는 `==`로 안 돼요.

```c
char a[] = "hi";
char b[] = "hi";

if (a == b) { ... }   // 이렇게 하면 안 됨

```

그래서 `strcmp(a, b)`를 써요.

결과는 딱 하나만 기억하면 돼요.

> - 같으면 0
> 

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char a[] = "apple";
    char b[] = "apple";

    if (strcmp(a, b) == 0) {
        printf("같아요\n");
    } else {
        printf("달라요\n");
    }

    return 0;
}

```

0이 아니면 다른 거예요. 그것만 알면 돼요.

---

## 10-8. (참고) `strcmp`는 이렇게 동작해요

비교도 결국 한 글자씩 봐요.

> - 다른 글자가 나오면 끝
> - 끝까지 같으면 같은 문자열
> 

```c
int my_strcmp(char a[], char b[]) {
    int i = 0;
    while (a[i] != '\0' && b[i] != '\0') {
        if (a[i] != b[i]) {
            return -1;  // 다르면 0이 아닌 값
        }
        i++;
    }
    return 0;  // 같으면 0
}

```

지금은 대충 이런 느낌이구나 정도만 알면 돼요.

---

## 10-9. 문자열 입력에서 자주 터지는 포인트

`scanf("%s")`는 공백에서 끊긴다고 했죠.

그래서 문장을 받으려면 다른 방법이 필요해요.

입문 단계에서는 일단 이 정도만 알고 가도 돼요.

> - 단어 입력: `scanf("%s", s)`
> - 공백 포함 문장 입력: 다른 방식이 필요함
> 

이 “다른 방식”은 다음 장에서 안전하게 다룰게요.

---

## 10-10. 직접 쳐볼 예시: 문자열 비교하기

복사하지 말고 직접 쳐보세요.

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char a[20], b[20];

    scanf("%s %s", a, b);

    if (strcmp(a, b) == 0) {
        printf("같아요\n");
    } else {
        printf("달라요\n");
    }

    return 0;
}

```

---

## 10-11. 미션

아래 중 하나만 해도 충분해요.

- 단어 2개를 입력받아서, 같으면 `OK`, 다르면 `NO` 출력하기
- 단어 1개를 입력받아서, 길이를 출력하기


---

## 10-12. 다음 장

다음 장에서는 “문장 입력”을 제대로 다룰 거예요.

> - 공백 포함 입력 받기
> - 입력 끝에 붙는 `\n` 처리하기
> - 문자열에서 제일 흔한 입력 실수 줄이기
> 

---

# 11장. 문자열 입력 — 공백, 줄바꿈, 그리고 안전하게 받기

## 11-1. 문자열 입력은 일단 단어만 받으면 돼요

지금까지 배운 `scanf("%s")`로 충분해요.

공백이 포함된 문장 입력은 조금 복잡해서,

지금 단계에서는 그냥 넘어가도 돼요.

> - 단어 입력: `scanf("%s", s)` — 이거면 충분
> - 문장 입력: 나중에 필요하면 배울 수 있어요
> 

---

## 11-2. `scanf("%s")`는 단어만 받아요

`scanf("%s", s)`는 공백을 만나면 끝나요.

그래서 입력이 이렇게 들어오면

> - `hello world`
> - `hello`만 들어가요
> 

```c
#include <stdio.h>

int main(void) {
    char s[20];
    scanf("%s", s);
    printf("%s\n", s);
    return 0;
}

```

지금은 이게 단점이 아니라,

> - "단어 입력 받을 때는 편하다"
> 

이렇게 생각하면 돼요.

---

## 11-3. (참고) 공백까지 포함하려면 `fgets`

지금 단계에서는 그냥 넘어가도 돼요.

나중에 필요하면 찾아보면 되는 내용이에요.

문장(한 줄)을 받는 방법이 `fgets`예요.

```c
#include <stdio.h>

int main(void) {
    char line[100];
    fgets(line, 100, stdin);
    printf("%s", line);
    return 0;
}

```

여기서 포인트는 두 개예요.

> - 100은 최대 길이(배열 크기)예요
> - 마지막에 `\n`이 같이 들어올 수 있어요
> 

지금은 이 정도만 알고 넘어가면 돼요.

---

## 11-4. 직접 쳐볼 예시: 단어 입력받기

복사하지 말고 직접 쳐보세요.

```c
#include <stdio.h>

int main(void) {
    char word[20];
    
    scanf("%s", word);
    printf("입력한 단어: %s\n", word);
    
    return 0;
}

```

---

## 11-5. 미션

아래 중 하나만 해도 충분해요.

- 단어 하나를 입력받아서 그대로 출력하기
- 단어 두 개를 입력받아서 각각 출력하기

---

## 11-6. 다음 장

다음 장에서는 이제 "함수"로 들어갈 거예요.

지금까지 만든 코드들이 슬슬 길어졌죠.

함수는 그걸 정리해주는 도구예요.

> - 코드를 묶어서 이름 붙이기
> - 같은 로직을 다시 쓰기
> - 문제를 더 작은 조각으로 나누기
> 

---

# 12장. 함수 — 코드를 묶어서 다시 쓰기

## 12-1. 함수는 “코드 덩어리에 이름 붙이기”예요

코드가 길어지면 이런 느낌이 와요.

> - 같은 패턴이 자꾸 반복된다
> - main이 너무 길어서 보기 싫다
> - "이 부분이 뭐을 하는지" 한눈에 안 들어온다
> 

이럴 때 함수를 쓰면 좋아요.

함수는 한 줄로 말하면 이거예요.

> - 여러 줄 코드를 묶고
> - 그 묶음에 이름을 붙여요
> 

---

## 12-2. 함수는 보통 “입력 → 처리 → 출력” 형태예요

함수는 이렇게 생각하면 편해요.

> - 입력: 함수에게 넘겨주는 값(매개변수)
> - 처리: 함수 안에서 하는 일
> - 출력: 함수가 돌려주는 값(반환값)
> 

---

## 12-3. 함수 기본 형태 (가장 흔한 모양)

```c
반환형 함수이름(매개변수들) {
    실행할 코드
    return 반환값;
}

```

여기서 중요한 포인트는 세 개예요.

> - 반환형: 이 함수가 "뭘 돌려주는지"
> - 함수이름: 이 코드 덩어리의 이름
> - 매개변수: 함수가 일하기 위해 필요한 재료
> 

---

## 12-4. 가장 쉬운 예: 두 수의 합을 돌려주는 함수

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main(void) {
    int x = add(3, 5);
    printf("%d\n", x);
    return 0;
}

```

여기서 감각은 이거예요.

> - `add(3, 5)`는 "계산해서 값 하나로 바꿔달라"는 뜻이에요
> - 그래서 변수에 넣을 수도 있고, 바로 출력할 수도 있어요
> 

---

## 12-5. 반환값이 필요 없으면 `void`

어떤 함수는 값을 돌려줄 필요가 없어요.

그냥 “실행”만 하면 될 때가 있죠.

그때는 반환형을 `void`로 해요.

```c
#include <stdio.h>

void sayHello(void) {
    printf("Hello!\n");
}

int main(void) {
    sayHello();
    return 0;
}

```

여기서 포인트는 두 개예요.

> - void는 "돌려줄 값 없음"
> - `sayHello()`는 그냥 실행시키는 느낌
> 

---

## 12-6. 함수는 “main을 짧게 만드는 도구”로 써도 돼요

입문에서 함수가 어려워지는 이유는 보통 이거예요.

> “함수”를 너무 거창하게 생각해서
> 

근데 처음엔 그냥 이렇게만 써도 돼요.

> - main에 있던 코드 일부를 잘라서
> - 함수로 빼고
> - 이름을 붙여서 읽기 쉽게 만들기
> 

---

## 12-7. 예시: 배열 합 구하기를 함수로 빼기

```c
#include <stdio.h>

int sumArray(int a[], int n) {
    int sum = 0;

    for (int i = 0; i < n; i++) {
        sum += a[i];
    }

    return sum;
}

int main(void) {
    int a[5];

    for (int i = 0; i < 5; i++) {
        scanf("%d", &a[i]);
    }

    printf("%d\n", sumArray(a, 5));
    return 0;
}

```

여기서 중요한 감각은 이거예요.

> - 배열은 통째로 "값 복사"가 아니라 "묶음 전달"처럼 넘어가요
> - 그래서 길이 n을 같이 넘겨주는 게 보통이에요
> 

---

## 12-8. 함수 선언이 필요한 순간이 있어요 (선언/정의 순서)

C는 보통 위에서 아래로 읽어요.

그래서 `main`에서 함수를 쓰려면

> 그 함수가 "있다"는 걸 먼저 알려줘야 하는 경우가 있어요
> 

그게 “함수 선언”이에요.

```c
#include <stdio.h>

int add(int a, int b);  // 선언

int main(void) {
    printf("%d\n", add(2, 4));
    return 0;
}

int add(int a, int b) { // 정의
    return a + b;
}

```

여기서 포인트는 이거예요.

> - 선언: "이런 함수가 있다" 미리 알려주기
> - 정의: "진짜 내용은 여기"
> 

---

## 12-9. 매개변수는 “함수 안에서 쓰는 지역 변수”처럼 보면 돼요

함수 괄호 안에 있는 `a`, `b`는

함수 안에서만 쓰는 변수예요.

> - 함수 밖에서는 못 써요
> - 함수가 끝나면 사라져요
> 

이 감각은 나중에 “스코프”에서 더 정확히 잡히는데

지금은 그냥 “함수 안 전용 변수”라고 생각하면 충분해요.

---

## 12-10. 직접 쳐볼 예시: 최댓값 함수를 만들기

```c
#include <stdio.h>

int max2(int a, int b) {
    if (a > b) return a;
    return b;
}

int main(void) {
    int x, y;
    scanf("%d %d", &x, &y);

    printf("%d\n", max2(x, y));
    return 0;
}

```

---

## 12-11. 미션

아래 중 두 개만 해도 충분해요.

- `min2(a, b)`를 만들어서 더 작은 값을 반환하기
- `countSpace(s)`를 만들어서 문자열 안의 공백 개수 세기 (for로 훑기)
- `sumArray(a, n)`처럼 `maxArray(a, n)`을 만들어서 배열 최댓값 반환하기


---

## 12-12. 다음 장

다음 장에서는 “함수로 넘어가면 꼭 붙는 이야기”를 할 거예요.

> - 값이 함수에 들어가면 어떻게 되는지
> - 왜 어떤 건 바뀌고, 어떤 건 안 바뀌는지
> 

즉, “전달 방식(값/주소)” 감각으로 들어가요.

---

# 13장. 값 전달과 주소 전달 — 왜 어떤 건 바뀌고 어떤 건 안 바뀌는가

## 13-1. 함수 쓰다 보면 꼭 한 번 막히는 지점이 있어요

함수를 쓰다 보면 이런 상황이 나와요.

> - 함수 안에서 `x`를 바꿨는데, `main`의 `x`는 그대로다
> - 배열은 함수에서 바꾸면 `main`에서도 바뀐다
> - `scanf`는 왜 변수 앞에 `&`를 붙이라고 하지?
> 

이 장은 그 차이를 “감각”으로 잡는 장이에요.

포인터 나온다고 겁먹지 마세요.

지금은 "왜 어떤 건 바뀌고 어떤 건 안 바뀌는지"만 잡으면 돼요.

---

## 13-2. 기본은 “값 전달”이에요

C에서 함수 호출은 기본적으로 이렇게 생각하면 돼요.

> - 함수에 값을 넘기면
> - 그 값이 "복사"돼서 들어가요
> 

즉, 함수 안에서 바꿔도 바깥 값은 안 바뀌는 게 기본이에요.

---

## 13-3. 예시: 함수 안에서 바꿨는데도 안 바뀌는 경우

```c
#include <stdio.h>

void addOne(int x) {
    x = x + 1;
}

int main(void) {
    int a = 10;
    addOne(a);
    printf("%d\n", a);  // 10
    return 0;
}

```

왜냐면 이 느낌이기 때문이에요.

> - `addOne(a)`는 "a를 복사해서 x에 넣어요"
> - 함수 안에서 바뀐 건 `x`이에요
> - `a`는 그대로예요
> 

---

## 13-4. 그럼 바깥 값을 바꾸려면?

바깥 값을 바꾸고 싶으면

“값”이 아니라 “주소”를 넘겨야 해요.

주소는 한 줄로 말하면 이거예요.

> 변수의 위치(어디에 저장돼 있는지)
> 

그 위치를 넘기면 함수가 “진짜 원본”을 건드릴 수 있어요.

---

## 13-5. 주소를 넘길 때 쓰는 게 `&`

변수 앞에 `&`를 붙이면

그 변수의 “주소”가 나와요.

```c
int a = 10;
& a   // a가 저장된 위치

```

---

## 13-6. 주소를 받는 쪽은 포인터(*)를 써요

주소를 받는 변수는 포인터라고 부르고

보통 이렇게 써요.

```c
int *p;

```

이 뜻은 이거예요.

> p에는 int의 주소가 들어간다
> 

---

## 13-7. 예시: 주소를 넘기면 진짜로 바뀐다

```c
#include <stdio.h>

void addOne(int *p) {
    *p = *p + 1;
}

int main(void) {
    int a = 10;
    addOne(&a);
    printf("%d\n", a);  // 11
    return 0;
}

```

여기서 핵심은 두 줄이에요.

> - `addOne(&a)` : a의 주소를 넘겨요
> - `*p = *p + 1` : 주소가 가리키는 "원본 값"을 바꿔요
> 

---

## 13-8. *는 "그 주소에 있는 값"이라고 생각하면 돼요

포인터에서 `*`는 이렇게 읽으면 편해요.

> - `p` : 주소
> - `*p` : 그 주소에 있는 값(원본 값)
> 

그래서 위 코드는 말로 하면 이거예요.

> - a의 주소를 받아서
> - 그 위치의 값을 1 증가시켜요
> 

**👇 `실행` 버튼을 눌러서 포인터가 변수를 가리키고 값을 바꾸는 과정을 확인해보세요.**

<pointerbasicviz />


---

## 13-9. `scanf`에서 `&`가 붙는 이유도 이거예요

`scanf`는 “입력을 변수에 저장”해야 해요.

근데 저장하려면 “변수 위치”를 알아야 하죠.

그래서 주소를 넘기는 거예요.

```c
int x;
scanf("%d", &x);

```

이걸 말로 하면 이 느낌이에요.

> - 정수를 하나 읽어서
> - x가 있는 위치에 넣어라
> 

---

## 13-10. 배열이 함수에서 바뀌는 이유 (포인터처럼 넘어감)

배열은 함수에 넘기면

대부분 “첫 칸의 주소”처럼 넘어간다고 보면 돼요.

그래서 함수 안에서 `a[0]`을 바꾸면

원본 배열이 바뀌어요.

```c
#include <stdio.h>

void setFirst(int a[]) {
    a[0] = 999;
}

int main(void) {
    int a[3] = {1, 2, 3};
    setFirst(a);
    printf("%d\n", a[0]); // 999
    return 0;
}

```

여기서 감각은 이거예요.

> - 배열은 값 복사가 아니라 "원본을 가리키는 것"이 넘어가요
> 

---

## 13-11. 그래서 배열 함수는 보통 길이를 같이 받는다

배열은 함수 안에서 `n`을 모르는 경우가 많아요.

그래서 보통 이렇게 써요.

> 배열 + 길이(n)를 같이 넘겨요
> 

```c
int sumArray(int a[], int n);

```

---

## 13-12. 직접 쳐볼 예시: swap(두 값 바꾸기)

두 값을 바꾸는 건 “주소 전달” 감각 잡기에 좋아요.

```c
#include <stdio.h>

void swap(int *x, int *y) {
    int tmp = *x;
    *x = *y;
    *y = tmp;
}

int main(void) {
    int a = 3, b = 7;
    swap(&a, &b);
    printf("%d %d\n", a, b); // 7 3
    return 0;
}

```

---

## 13-13. 자주 하는 실수 모음

여기서 많이 터져요.

> - `scanf("%d", x);`처럼 `&`를 빼먹기
> - 포인터 변수에 아무 주소도 안 넣고 `*p`를 쓰기 (위험)
> - `*p`랑 `p`를 섞어서 읽기
> - "값 전달이 기본"이라는 걸 잊고 함수가 바깥 값을 바꿀 거라 착각하기
> 

---

## 13-14. 미션

아래 중 두 개만 해도 충분해요.

- `swap`을 직접 다시 작성해서 동작 확인하기
- `addTwo(int *p)` 함수를 만들고 main에서 `&a`를 넘겨서 실제로 바뀌는지 확인하기
- `setZero(int a[], int n)`를 만들어서 배열을 전부 0으로 만들기


---

## 13-15. 다음 장

다음 장에서는 이 흐름으로 자연스럽게 넘어가요.

> - 주소를 쓰기 시작했어요
> - 그러면 "포인터 문법"을 제대로 한 번 정리해야 해요
> 

그래서 다음 장은 **포인터 기초**로 들어가요.

---

# 14장. 포인터 기초 — 주소를 다루는 문법을 “딱 필요한 만큼”만

## 14-1. 포인터는 무서운 게 아니라 “표현이 낯선 것”이에요

포인터는 개념이 이상하다기보다

기호가 많아서 처음에 겁이 나요.

근데 솔직히 말하면

지금 완벽히 이해 안 해도 돼요.

일단 "이런 게 있구나" 하고 넘어가고

나중에 쓰다 보면 자연스럽게 익숙해져요.

이 장에서는 딱 이것만 잡을 거예요.

> - 포인터는 "주소를 저장하는 변수"예요
> - &는 "주소를 꺼내는 기호"예요
> - *는 "그 주소의 값을 꺼내는 기호"예요
> 

이 세 줄만 잡히면, 포인터는 생각보다 금방 익숙해져요.

---

## 14-2. 주소는 “변수가 저장된 위치”예요

변수는 값이 들어 있는 상자고,

주소는 그 상자가 놓여 있는 자리예요.

```c
int a = 10;

```

여기서 `a`는 값이고,

`&a`는 주소예요.

---

## 14-3. `&` : 주소를 꺼내는 연산자

`&a`는 “a의 주소”예요.

```c
int a = 10;
printf("%p\n", (void*)&a);

```

여기서 `%p`는 “주소 출력용”이에요.

(주소는 숫자처럼 보이지만, 그냥 주소라고 생각하면 돼요.)

---

## 14-4. 포인터 변수는 주소를 담는 그릇이에요

정수 주소를 담는 포인터는 이렇게 선언해요.

```c
int *p;

```

이 뜻은 이거예요.

> p에는 int의 주소가 들어가요
> 

그래서 이런 게 자연스러워요.

```c
int a = 10;
int *p = &a;

```

---

## 14-5.  : 그 주소에 있는 값을 꺼내기

이제 `p`는 주소니까,

그 주소에 있는 “진짜 값”을 보고 싶으면 `*p`를 써요.

```c
int a = 10;
int *p = &a;

printf("%d\n", *p);  // 10

```

여기서 핵심은 이거예요.

> - `p`는 주소
> - `*p`는 값
> 

---

## 14-6. 포인터로 값을 바꾸면 원본이 바뀌어요

- `p`에 값을 넣는다는 건

> "p가 가리키는 위치의 값을 바꾼다"
> 

예시를 보면 바로 와요.

```c
#include <stdio.h>

int main(void) {
    int a = 10;
    int *p = &a;

    *p = 99;

    printf("%d\n", a);  // 99
    return 0;
}

```

---

## 14-7. 포인터는 함수랑 만나면 진짜 자주 써요

앞 장에서 했던 패턴이 그대로예요.

> - 함수가 바깥 값을 바꾸게 하고 싶다
> - 그럼 주소를 넘긴다
> 

```c
void addOne(int *p) {
    *p = *p + 1;
}

```

---

## 14-8. `int* p` vs `int *p` 뭐가 맞아요?

둘 다 같은 뜻이에요.

초반에는 이 스타일을 추천해요.

> int *p
> 

이렇게 쓰면 `*`가 “변수 쪽에 붙어 있다”는 느낌이 나서

`p`가 포인터라는 걸 눈으로 구분하기 좋아요.

---

## 14-9. 포인터를 여러 개 선언할 때 자주 터져요

이건 초보 때 진짜 자주 망해요.

```c
int* p, q;

```

이렇게 쓰면

> - `p`는 포인터
> - `q`는 그냥 `int`
> 

이 돼요.

그래서 초반에는 아예 이렇게 쓰는 걸 추천해요.

> 포인터는 한 줄에 하나만 선언하기
> 

```c
int *p;
int *q;

```

---

## 14-10. “아무 주소도 없는 포인터”는 위험해요

이게 포인터가 무섭다고 느끼는 가장 큰 이유예요.

```c
int *p;
*p = 10;  // 위험

```

여기서 `p`는 아직 어디를 가리키는지 정해지지 않았어요.

그래서 `*p`를 쓰면 터질 수 있어요.

포인터는 이 규칙만 지키면 훨씬 안전해져요.

> 포인터를 만들면, 반드시 "유효한 주소"를 넣고 쓰세요
> 

---

## 14-11. 포인터에 `NULL`을 넣는 이유

가끔 이런 걸 봐요.

```c
int *p = NULL;

```

이건 말 그대로 이 뜻이에요.

> - 지금 `p`는 아무 것도 가리키지 않아요
> 

초반에는 “안전하게 비워두는 표시” 정도로만 이해해도 충분해요.

---

## 14-12. 직접 쳐볼 예시: 포인터로 값 바꾸기

```c
#include <stdio.h>

int main(void) {
    int a = 5;
    int *p = &a;

    printf("%d\n", a);   // 5
    printf("%d\n", *p);  // 5

    *p = *p + 10;

    printf("%d\n", a);   // 15
    printf("%d\n", *p);  // 15

    return 0;
}

```

여기서 포인트는 딱 이거예요.

> - `a`랑 `*p`는 결국 같은 값을 봐요
> - 이유는 `p`가 `a`의 주소를 들고 있기 때문이에요
> 

---

## 14-13. 자주 하는 실수 모음

포인터는 실수 패턴이 거의 정해져 있어요.

> - p에 주소를 넣기 전에 `*p`를 써버림
> - &를 안 붙여서 값이 넘어가 버림 (scanf, swap에서 자주)
> - `p`와 `*p`를 섞어서 읽음
> - 포인터 여러 개를 한 줄에 선언하다가 한 개만 포인터가 됨
> 

---

## 14-14. 미션

아래 중 두 개만 해도 충분해요.

- `int a = 10; int *p = &a;`로 시작해서 `*p`를 바꿔보고 `a`가 바뀌는지 확인하기
- `addOne(int *p)` 함수를 만들고 main에서 `&a`를 넘겨서 실제로 바뀌는지 확인하기
- `swap`을 다시 써보고, `&`를 빼면 왜 안 되는지 직접 에러/결과로 확인하기


---

## 14-15. 다음 장

다음 장에서는 이걸로 이어져요.

> - 포인터 문법을 배웠어요
> - 근데 배열이랑 만나는 순간, 포인터가 "갑자기 자주 보여요"
> 

그래서 다음 장은 **배열과 포인터의 관계**로 갈 거예요.

---

# 15장. 배열과 포인터 — “배열이 포인터처럼 보이는” 이유

## 15-1. 이 장은 사실 한 문장만 이해하면 끝나요

배열이랑 포인터가 갑자기 같이 나오면

대부분 여기서 멘붕 와요.

근데 이 장은 핵심이 하나예요.

> - 배열 이름은 “첫 번째 칸의 주소”처럼 동작해요
> 

이 문장만 익숙해지면,

배열/포인터 문제는 훨씬 덜 무서워져요.

---

## 15-2. 배열 이름은 값이 아니라 “위치” 느낌이에요

배열을 만들면 이렇게 되죠.

```c
int a[5];

```

여기서 `a`는 `a[0]` 그 자체가 아니에요.

> - a는 “배열 첫 칸이 시작하는 위치”를 가리키는 느낌이에요
> 

그래서 주소 출력도 이렇게 돼요.

```c
printf("%p\n", (void*)a);     // a의 시작 주소
printf("%p\n", (void*)&a[0]); // 첫 칸 주소

```

둘이 같은 값이 나오는 경우가 많아요.

---

## 15-3. `a`와 `&a[0]`는 거의 같은 느낌이에요

이건 그냥 자주 쓰는 등식처럼 외워도 돼요.

> - a ≈ &a[0]
> - 완전히 "항상 같다"라고 말하면 예외가 있어서 복잡해지지만, 입문 단계에서는 이렇게 생각해도 충분해요
> 

---

## 15-4. 그래서 포인터에 배열을 넣을 수 있어요

배열은 시작 주소처럼 동작하니까,

포인터에 바로 담을 수 있어요.

```c
int a[5] = {10, 20, 30, 40, 50};
int *p = a;

```

여기서 핵심은 이거예요.

여기서 핵심은 이거예요.

> - p는 a[0]의 주소를 들고 있어요
> 

---

## 15-5. `p[i]`는 사실 `*(p + i)`예요

이게 포인터 파트에서 제일 신기한 포인트예요.

배열 접근은 이렇게 하잖아요.

```c
a[2]

```

근데 포인터로도 이렇게 쓸 수 있어요.

```c
*(a + 2)

```

그래서 이런 게 성립해요.

그래서 이런 게 성립해요.

> - a[i] = *(a + i)
> - p[i] = *(p + i)
> 

---

## 15-6. 포인터에서 `+1`은 “한 칸 이동”이에요

이 부분이 초보가 제일 헷갈려요.

정수에서 `+1`은 그냥 1 더하기인데,

포인터에서 `p + 1`은 이거예요.

> - 다음 칸으로 이동하기
> - 여기서 "칸"은 자료형 기준이에요.
> - int *p면 p+1은 "다음 int 칸"이에요
> - char *p면 p+1은 "다음 char 칸"이에요
> 

**👇 `p++`을 눌러서 포인터가 배열 칸을 건너뛰는 모습을 확인해보세요.**

<arraypointerviz />


---

## 15-7. 배열을 포인터로 훑는 예시

```c
#include <stdio.h>

int main(void) {
    int a[5] = {10, 20, 30, 40, 50};
    int *p = a;

    printf("%d\n", *p);       // 10
    printf("%d\n", *(p + 1)); // 20
    printf("%d\n", p[2]);     // 30

    return 0;
}

```



> - *p는 첫 칸이에요
> - *(p+1)은 두 번째 칸이에요
> - p[2]도 결국 같은 방식이에요
> 

---

## 15-8. 함수에 배열을 넘기면 “포인터처럼” 받게 돼요

배열을 함수에 넘길 때 이런 식으로 쓰죠.

```c
void printFirst(int a[]) {
    printf("%d\n", a[0]);
}

```

근데 사실 이건 이런 뜻이랑 거의 같아요.

```c
void printFirst(int *a) {
    printf("%d\n", a[0]);
}

```

그래서 입문 단계에서는 이렇게 받아들이면 편해요.



> - 함수에서 int a[]는 사실상 int *a처럼 동작해요
> 

---

## 15-9. 배열을 함수에서 처리하는 기본 패턴



> - 배열 시작 주소
> - 길이
> - 왜냐면 배열은 함수로 넘어갈 때 “크기 정보”가 같이 안 넘어오는 경우가 많기 때문이에요.
> 

그래서 이런 형태가 기본이에요.

```c
int sum(int *a, int n) {
    int s = 0;
    for (int i = 0; i < n; i++) s += a[i];
    return s;
}

```

---

## 15-10. `sizeof`로 배열 길이 구하는 건 “main에서만” 가능해요

초보가 여기서 많이 넘어져요.

`main`에서 배열을 직접 들고 있을 때는 가능해요.

```c
int a[5];
int n = sizeof(a) / sizeof(a[0]);

```

근데 함수를 타고 들어가면,

배열이 포인터처럼 취급되면서 `sizeof` 결과가 달라질 수 있어요.

입문 단계에서는 이렇게 외우면 안전해요.

> - sizeof로 길이 구하는 건 "배열을 직접 들고 있을 때만" 믿을 수 있어요
> - 함수로 넘길 땐 길이를 같이 넘겨야 해요
> 

---

## 15-11. 직접 쳐볼 예시: 배열 합을 함수로 만들기

```c
#include <stdio.h>

int sum(int *a, int n) {
    int s = 0;
    for (int i = 0; i < n; i++) {
        s += a[i];
    }
    return s;
}

int main(void) {
    int a[5] = {1, 2, 3, 4, 5};
    int n = 5;

    printf("%d\n", sum(a, n));
    return 0;
}

```

여기서 핵심은 이거예요.

> - sum(a, n)에서 a는 시작 주소처럼 넘어가요
> - 그래서 함수가 배열을 "쭉 훑을 수 있어요"
> 

---

## 15-12. 자주 하는 실수 모음

배열+포인터에서 제일 흔한 실수는 이것들이에요.

배열+포인터에서 제일 흔한 실수는 이것들이에요.

> - p(주소)와 *p(값)를 섞어서 써요
> - p+1을 "숫자 1 더하기"로 생각해요
> - 함수에서 배열 길이를 sizeof로 구하려고 해요
> - n을 잘못 넘겨서 범위를 벗어나요 (i <= n 같은 실수)
> 

---

## 15-13. 미션

아래 중 두 개만 해도 충분해요.

아래 중 두 개만 해도 충분해요.

- `a[i]`와 `*(a+i)`가 같은지 직접 출력해보기
- 배열을 함수에 넘겨서 최댓값을 찾는 `max(int *a, int n)` 만들기
- 포인터 `p`를 써서 `a[0]`부터 `a[4]`까지 출력해보기 (`*(p+i)`로)


---

## 15-14. 다음 장

다음은 자연스럽게 이걸로 이어져요.

다음은 자연스럽게 이걸로 이어져요.

> - 배열은 첫 칸 주소처럼 동작해요
> - 그럼 "문자열"은 뭐냐고요?
> - 사실 문자열은 char 배열이에요
> - 그래서 다음 장은 **문자열(문자 배열)**로 가면 딱 자연스러워요
> 

---

# 16장. 문자열 — “char 배열”로 생각하면 끝나요

## 16-1. 문자열이 어렵게 느껴지는 이유

문자열이 갑자기 나오면

사람들이 겁먹는 이유가 하나 있어요.

사람들이 겁먹는 이유가 하나 있어요.

> - 문자열은 "특별한 자료형" 같아 보이기 때문이에요
> - 근데 C에서 문자열은 특별하지 않아요
> - 문자열은 char 배열이에요
> - 이 한 줄이 시작이에요
> 

---

## 16-2. 문자 하나 vs 문자열

문자 하나는 `char`예요.

```c
char c = 'A';

```

문자열은 “문자 여러 개”예요.

```c
char s[] = "ABC";

```

차이는 이거예요.

차이는 이거예요.

> - 문자는 작은따옴표 `' '`
> - 문자열은 큰따옴표 `" "`
> 

---

## 16-3. 문자열의 진짜 규칙: 끝에 `\0`이 붙어요

C 문자열은 진짜로 이것 때문에 돌아가요.

C 문자열은 진짜로 이것 때문에 돌아가요.

> - 문자열은 맨 끝에 `\0`(널 문자)가 들어가요
> - 그래서 `"ABC"`는 실제로 이렇게 저장돼요
> - 'A' 'B' 'C' `\0`
> - 이 `\0`이 "여기서 끝" 표시예요
> 

**👇 `다음 글자`를 눌러서 문자열이 메모리에 채워지는 모습을 확인해보세요.**

<stringnullviz />


---

## 16-4. 그래서 배열 크기를 생각해야 해요

예를 들어 3글자 넣고 싶으면,

널 문자까지 포함해서 4칸이 필요해요.

```c
char s[4] = "ABC";

```

이 감각이 중요해요.

이 감각이 중요해요.

> - 문자열 길이 + 1 칸이 필요해요 (`\0` 때문)
> 

---

## 16-5. 문자열 출력은 `%s`

정수는 `%d`, 실수는 `%f`였죠.

문자열은 `%s`예요.

```c
#include <stdio.h>

int main(void) {
    char s[] = "Hello";
    printf("%s\n", s);
    return 0;
}

```

---

## 16-6. 문자열 입력은 `scanf("%s", s)`인데, 조심할 점이 있어요

입력도 이렇게 받을 수 있어요.

```c
char s[100];
scanf("%s", s);

```

여기서 포인트는 이거예요.

> - 문자열 배열 이름 s 자체가 시작 주소처럼 동작해서 `&`를 안 붙이는 경우가 많아요
> 

그리고 더 중요한 조심 포인트가 있어요.

그리고 더 중요한 조심 포인트가 있어요.

> - `%s` 입력은 공백에서 끊겨요
> - 길이 제한 없이 받으면 위험할 수 있어요
> 

입문 단계에서는 일단 이렇게만 기억해도 돼요.

> - 공백 없는 한 단어 입력이면 `%s`로 충분해요
> - 문장 입력은 다음 장에서 더 안전한 방법으로 배워요
> 

---

## 16-7. 문자열은 배열이라서 인덱스로 접근 가능해요

문자열도 배열이니까, 이렇게 할 수 있어요.

```c
char s[] = "ABC";
printf("%c\n", s[0]); // A
printf("%c\n", s[1]); // B
printf("%c\n", s[2]); // C

```

여기서 중요한 건 이거예요.

여기서 중요한 건 이거예요.

> - `s[3]`은 `\0`일 가능성이 커요
> 

---

## 16-8. 문자열 길이는 “\0 만날 때까지 세기”예요

C는 문자열 길이를 “저장해두지” 않고

끝 표시(`\0`)를 보고 판단해요.

그래서 길이 계산은 이런 느낌이에요.

```c
int len = 0;
while (s[len] != '\0') {
    len++;
}

```

---

## 16-9. 직접 구현 1: `strlen` 느낌 내기

```c
#include <stdio.h>

int my_strlen(char *s) {
    int len = 0;
    while (s[len] != '\0') {
        len++;
    }
    return len;
}

int main(void) {
    char s[100];
    scanf("%s", s);

    printf("%d\n", my_strlen(s));
    return 0;
}

```

포인트는 딱 이거예요.

포인트는 딱 이거예요.

> - 문자열은 `\0`까지 세면 길이가 나와요
> - 결국 반복문 + 배열이에요
> 

---

## 16-10. 직접 구현 2: 문자열 복사(`strcpy`) 느낌

문자열 복사는 “한 글자씩 옮기기”예요.

`'\0'`까지 같이 옮겨야 끝이 나요.

```c
#include <stdio.h>

void my_strcpy(char *dst, char *src) {
    int i = 0;
    while (src[i] != '\0') {
        dst[i] = src[i];
        i++;
    }
    dst[i] = '\0';
}

int main(void) {
    char a[100];
    char b[100];

    scanf("%s", a);
    my_strcpy(b, a);

    printf("%s\n", b);
    return 0;
}

```

---

## 16-11. 직접 구현 3: 문자열 비교(`strcmp`) 느낌

문자열 비교는 이런 감각이에요.

문자열 비교는 이런 감각이에요.

> - 앞에서부터 한 글자씩 비교해요
> - 다르면 거기서 끝나요
> - 끝까지 같으면 같은 문자열이에요
> 

---```c
#include <stdio.h>

int my_strcmp(char *a, char *b) {
    int i = 0;
    while (a[i] != '\0' && b[i] != '\0') {
        if (a[i] != b[i]) {
            return a[i] - b[i];
        }
        i++;
    }
    return a[i] - b[i];
}

int main(void) {
    char s1[100], s2[100];
    scanf("%s %s", s1, s2);

    int r = my_strcmp(s1, s2);

    if (r == 0) printf("SAME\n");
    else if (r < 0) printf("s1 is smaller\n");
    else printf("s1 is bigger\n");

    return 0;
}

```

---

## 16-12. 자주 하는 실수 모음

문자열에서 가장 많이 터지는 실수는 이거예요.



> - 배열 크기를 너무 작게 잡아요 (`\0` 자리 없음)
> - `\0`을 빼먹고 복사/출력해서 이상한 값이 나와요
> - 문자열을 `==`로 비교하려고 해요
> - 입력이 길어지면 배열 범위를 넘을 수 있다는 걸 잊어요
> 

---

## 16-13. 미션

아래 중 두 개만 해도 충분해요.

아래 중 두 개만 해도 충분해요.

- 입력받은 문자열 길이를 직접 세서 출력하기 (`my_strlen`)
- 문자열 두 개를 입력받아서 같은지 판별하기 (`my_strcmp == 0`)
- 문자열을 하나 입력받아서 "역순으로 출력"해보기 (배열 인덱스 역방향 연습)


---

## 16-14. 다음 장

문자열까지 왔으면 이제 이런 게 가능해져요.

문자열까지 왔으면 이제 이런 게 가능해져요.

> - 글자 여러 개를 저장하고
> - 반복문으로 처리하고
> - 직접 함수처럼 만들어서 쓸 수 있어요
> 

그래서 다음 장은 딱 자연스러워요.

> - 함수를 직접 만들고 잘 쓰는 법
> - "입력 → 처리 → 출력"을 함수로 분리하는 감각
> 

---

# 17장. 함수 — “코드 덩어리”를 이름 붙여서 재사용하기

## 17-1. 함수는 왜 필요하냐면

코드가 길어지면 이런 일이 생겨요.

코드가 길어지면 이런 일이 생겨요.

> - 같은 패턴이 계속 반복돼요
> - 한 번 고치면 여기저기 다 고쳐야 해요
> - `main()`이 너무 길어서 뭐 하는지 안 보여요
> 

그래서 함수를 써요.

> - 함수는 "코드 덩어리"에 이름을 붙이는 거예요
> - 그리고 필요할 때 불러서 실행하는 거예요
> 

---

## 17-2. 함수의 기본 형태

함수는 보통 이렇게 생겼어요.

```c
반환형 함수이름(매개변수들) {
    실행할 코드
    return 반환값;
}

```

말로 풀면 이거예요.

말로 풀면 이거예요.

> - 반환형: 결과가 뭐냐 (int, double, void 등)
> - 함수이름: 부를 이름
> - 매개변수: 함수가 사용할 재료(입력)
> - return: 결과를 돌려주기
> 

---

## 17-3. 제일 간단한 함수부터

“두 수를 더한 결과”를 돌려주는 함수예요.

```c
int add(int a, int b) {
    return a + b;
}

```

이제 `main()`에서 이렇게 쓸 수 있어요.

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main(void) {
    printf("%d\n", add(3, 5));
    return 0;
}

```

포인트는 이거예요.

포인트는 이거예요.

> - 함수는 "계산을 대신 해주는 부품"이에요
> - add(3, 5)는 결과값 하나로 바뀌어요
> 

---

## 17-4. `return`은 “결과를 돌려준다” + “함수를 끝낸다”

`return`을 만나면 함수는 끝나요.

```c
int f(int x) {
    if (x > 0) return 1;
    return 0;
}

```

포인트는 이거예요.

포인트는 이거예요.

> - return은 값을 돌려주는 동시에, 그 자리에서 함수를 종료해요
> 

---

## 17-5. 반환값이 없을 수도 있어요 (`void`)

“출력만 하는 함수”처럼 결과를 돌려줄 필요가 없는 경우가 있어요.

```c
void print_hello(void) {
    printf("Hello\n");
}

```

이런 건 반환형을 `void`로 해요.

```c
#include <stdio.h>

void print_hello(void) {
    printf("Hello\n");
}

int main(void) {
    print_hello();
    return 0;
}

```

포인트는 이거예요.

포인트는 이거예요.

> - void는 "돌려줄 값 없음"이라는 뜻이에요
> - 대신 함수 내부에서 출력/처리만 하고 끝나요
> 

---

## 17-6. 함수 만들 때 가장 좋은 기준: “한 번 더 쓰게 될 것 같냐”

함수로 빼는 기준을 딱 이렇게 잡으면 편해요.

함수로 빼는 기준을 딱 이렇게 잡으면 편해요.

> - 같은 코드가 2번 이상 나온다 → 함수 후보
> - main()이 너무 길다 → 큰 덩어리를 함수로 나누기
> - "이 부분이 뭔지" 이름만 봐도 알게 하고 싶다 → 함수로 빼기
> 

---

## 17-7. 예시: 합 구하는 코드를 함수로 빼기

배열 합 구하는 패턴을 함수로 빼볼게요.

```c
#include <stdio.h>

int array_sum(int a[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += a[i];
    }
    return sum;
}

int main(void) {
    int a[5];

    for (int i = 0; i < 5; i++) {
        scanf("%d", &a[i]);
    }

    printf("%d\n", array_sum(a, 5));
    return 0;
}

```

여기서 중요한 감각은 이거예요.

여기서 중요한 감각은 이거예요.

> - 함수는 "입력(배열, 길이)"을 받아요
> - 그리고 "결과(합)"를 돌려줘요
> 

---

## 17-8. 배열을 함수로 넘길 때의 규칙(딱 필요한 만큼만)

배열을 함수로 넘기면 이런 느낌이에요.

배열을 함수로 넘기면 이런 느낌이에요.

> - 배열 전체가 복사되는 게 아니에요
> - 시작 위치(첫 칸)를 넘기는 느낌이에요
> - 그래서 보통 길이 n을 같이 넘겨요
> 

---
그래서 이 형태가 자주 나와요.

그래서 이 형태가 자주 나와요.

> - func(arr, n)
> 

---

## 17-9. 함수에서 자주 터지는 포인트

초반에 자주 실수하는 것만 정리하면 이거예요.

초반에 자주 실수하는 것만 정리하면 이거예요.

> - 함수 선언/정의 위치 때문에 컴파일 에러가 나요
> - 매개변수 개수/타입이 안 맞아서 이상한 값이 나와요
> - return 타입이랑 실제 반환값이 안 맞아요
> - void인데 값을 return 하려 해요 (또는 그 반대)
> 

---
초반에는 이렇게만 기억해도 돼요.

초반에는 이렇게만 기억해도 돼요.

> - 함수는 "입력 타입"과 "출력 타입"이 정확해야 해요
> 

---

## 17-10. 작은 습관: 함수 위에 “한 줄 설명” 붙이기

이거 하면 코드가 갑자기 교재처럼 깔끔해져요.

```c
// n개의 정수를 담은 배열 a의 합을 반환한다
int array_sum(int a[], int n) { ... }

```

---

## 17-11. 미션

아래 중 두 개만 해도 충분해요.

아래 중 두 개만 해도 충분해요.

- 배열 최댓값 구하는 함수를 만들어서 `main()`에서 호출하기
- 문자열 길이 구하는 `my_strlen`을 함수로 만들고 재사용하기
- "짝수 개수 세기" 함수를 만들고, 입력 배열을 넣어 결과 출력하기


---

## 17-12. 다음 장

함수를 배우면 다음으로 자연스럽게 이어지는 게 있어요.

함수를 배우면 다음으로 자연스럽게 이어지는 게 있어요.

> - 변수가 어디까지 살아있냐(범위)
> - 함수 안/밖에서 변수가 어떻게 다르냐
> 

---
그래서 다음 장에서는

그래서 다음 장에서는

> - 지역 변수 / 전역 변수
> - 그리고 "변수 범위" 감각
> 

이걸 딱 겁 안 나게 정리해볼게요.

---

# 18장. 변수의 범위(스코프) — “얘가 어디까지 살아있냐”만 잡고 가기

## 18-1. 함수 만들기 시작하면 꼭 생기는 의문

함수를 쓰다 보면 이런 게 헷갈려요.

함수를 쓰다 보면 이런 게 헷갈려요.

> - main에 있는 변수는 함수에서 못 쓰네?
> - 함수 안에서 만든 변수는 함수 끝나면 사라지네?
> - 이름이 같은 변수를 또 만들면 뭐가 우선이지?
> - 전역 변수는 왜 쓰지 말라 그러는지 감이 안 오네?
> 

---
이 장은 이걸 **겁 안 나게 정리**하는 장이에요.

---

## 18-2. 변수는 “보이는 범위”가 있어요

변수는 아무 데서나 보이는 게 아니에요.

변수는 아무 데서나 보이는 게 아니에요.

> - 변수가 "선언된 위치" 기준으로 어디까지 접근 가능한지(보이는지)가 정해져요
> - 그걸 **범위(scope)**라고 불러요
> 

---
일단 이 한 줄만 잡으면 돼요.

---

## 18-3. 가장 기본: 블록 `{ }` 안에서 만든 변수는 그 안에서만

C에서 `{ }`는 “영역”이에요.

C에서 `{ }`는 "영역"이에요.

> - { } 안에서 선언한 변수는 그 { } 안에서만 살아 있어요
> - 밖으로 나오면 못 써요
> 

---
예시를 볼게요.

```c
#include <stdio.h>

int main(void) {
    int a = 10;

    if (a > 0) {
        int x = 3;
        printf("%d\n", x);   // OK
    }

    // printf("%d\n", x);    // ERROR (x를 모름)
    return 0;
}

```

포인트는 이거예요.

포인트는 이거예요.

> - x는 if 블록 안에서만 존재해요
> - 블록 밖에서는 "없는 변수" 취급해요
> 

---

## 18-4. 함수 안의 변수는 “그 함수 안에서만”

함수 안에서 만든 변수는 **지역 변수**예요.

함수 안에서 만든 변수는 **지역 변수**예요.

> - 지역 변수는 함수 안에서만 보여요
> - 함수가 끝나면 같이 사라져요
> 

---
```c
#include <stdio.h>

void f(void) {
    int x = 5;
    printf("%d\n", x);
}

int main(void) {
    f();
    // printf("%d\n", x);  // ERROR
    return 0;
}

```

---

## 18-5. 이름이 같은 변수를 또 만들면? “가까운 게 이김”

이건 초반에 한 번쯤 겪어요.

```c
#include <stdio.h>

int main(void) {
    int x = 10;

    {
        int x = 99;
        printf("%d\n", x);  // 99
    }

    printf("%d\n", x);      // 10
    return 0;
}

```

여기서 감각은 이거예요.



> - 안쪽 블록의 x가 바깥 x를 잠깐 가려요
> - 블록을 벗어나면 바깥 x가 다시 보여요
> 

초반엔 이렇게만 하면 안전해요.



> - 변수 이름은 가능하면 겹치지 않게 쓰기
> 

---

## 18-6. 전역 변수는 “함수 밖에 만든 변수”

파일 맨 위(함수 바깥)에 만들면 전역 변수예요.



> - 전역 변수는 “모든 함수에서 접근 가능해져요"
> - 대신 너무 쉽게 여기저기서 바뀌어서
> - 코드가 커질수록 추적이 어려워져요
> 

예시.

```c
#include <stdio.h>

int g = 0;  // 전역 변수

void addOne(void) {
    g++;
}

int main(void) {
    addOne();
    addOne();
    printf("%d\n", g); // 2
    return 0;
}

```

---

## 18-7. “전역 변수가 나쁜 건 아님” 근데 초반엔 조심

전역 변수가 무조건 나쁜 건 아니에요.

근데 입문자가 전역을 쓰기 시작하면 자주 이렇게 돼요.

> - 어디서 값이 바뀌었는지 추적이 안 돼요
> - 함수가 "입력 없이도 결과가 바뀌는" 이상한 모양이 돼요
> - 디버깅이 갑자기 어려워져요
> 

그래서 초반 기준은 이거로 가면 편해요.



> - 웬만하면 지역 변수 + 매개변수로 전달
> - 전역은 "진짜 공통 상태"에만 (그리고 최소화)
> 

---

## 18-8. 지역 변수는 “초기화 안 하면 쓰레기 값”일 수 있어요

이거는 실전에서 진짜 많이 터져요.

```c
#include <stdio.h>

int main(void) {
    int x;
    printf("%d\n", x); // 이상한 값 나올 수 있음
    return 0;
}

```

그래서 입문 단계에서는 이 습관이 좋아요.

그래서 입문 단계에서는 이 습관이 좋아요.

> - 변수를 만들면 바로 초기화하기
> - 특히 sum, cnt, mx 같은 누적 변수는 무조건 초기화하기
> 

---

## 18-9. `static` 지역 변수: “함수 끝나도 값이 남는다” (맛보기)

가끔 이런 패턴이 필요할 때가 있어요.

가끔 이런 패턴이 필요할 때가 있어요.

> - 함수를 몇 번 호출했는지 세고 싶다
> - 이전 호출 결과를 기억하고 싶다
> 

---
그럴 때 `static`을 써요.

```c
#include <stdio.h>

void counter(void) {
    static int c = 0;
    c++;
    printf("%d\n", c);
}

int main(void) {
    counter(); // 1
    counter(); // 2
    counter(); // 3
    return 0;
}

```

포인트는 이거예요.

포인트는 이거예요.

> - static이면 함수가 끝나도 값이 유지돼요
> - 일반 지역 변수면 호출마다 새로 만들어져요
> 

---
입문에서는 **“이런 게 있구나” 정도면 충분**해요.

---

## 18-10. 한 번에 정리 (이 장 핵심)

이것만 기억하면 돼요.

이것만 기억하면 돼요.

> - { } 안에서 만든 변수는 { } 안에서만 써요
> - 함수 안에서 만든 변수는 그 함수 안에서만 써요 (지역 변수)
> - 함수 바깥에서 만든 변수는 어디서든 보여요 (전역 변수)
> - 이름이 겹치면 "가까운 변수"가 우선해요
> - 지역 변수는 초기화 습관이 중요해요
> - static은 "값이 남는 지역 변수"예요 (맛보기)
> 

---

## 18-11. 직접 쳐볼 예시: 스코프 체감하기

```c
#include <stdio.h>

void f(void) {
    int x = 100;
    printf("in f: %d\n", x);
}

int main(void) {
    int x = 10;
    printf("in main: %d\n", x);

    {
        int x = 99;
        printf("in block: %d\n", x);
    }

    printf("after block: %d\n", x);

    f();
    return 0;
}

```

---

## 18-12. 미션

아래 중 두 개만 해도 충분해요.

아래 중 두 개만 해도 충분해요.

- sum 변수를 선언만 하고 더하기를 돌려서 확인해보기 (결과가 이상해지는지)
- 전역 변수 `g`를 만들어서 함수가 몇 번 호출됐는지 세보기 (어디서 바뀌는지 추적하기)
- static 카운터 예제를 보고, static을 빼면 왜 매번 1이 나오는지 확인하기


---

## 18-13. 다음 장

다음 장에서는 드디어 **구조체**로 갈 거예요.

다음 장에서는 드디어 **구조체**로 갈 거예요.

> - int만으로는 표현하기 힘든 "한 덩어리 데이터"를 묶어서 다루는 방법이에요
> - 예: 학생(이름, 학번, 점수), 좌표(x, y), 날짜(년/월/일)
> 

---
즉, **“서로 다른 타입을 한 묶음으로”** 만드는 문법이에요.

---

# 19장. 구조체 — “서로 다른 값”을 한 덩어리로 묶기

## 19-1. 배열까지 오면 이런 한계가 보여요

배열은 편하지만 이런 상황이 나와요.

배열은 편하지만 이런 상황이 나와요.

> - 학생 1명의 정보가 있어요
> - 이름(문자열), 학번(정수), 점수(정수)
> - 이걸 따로따로 변수로 들고 있으면 너무 흩어져요
> - 배열로도 애매해요 (자료형이 다 다르니까)
> 

---
그래서 필요한 게 구조체예요.

그래서 필요한 게 구조체예요.

> - 서로 다른 자료형을 하나의 "묶음"으로 만들기
> 

---

## 19-2. 구조체는 “새로운 자료형 만들기” 느낌이에요

구조체는 이렇게 생각하면 돼요.

구조체는 이렇게 생각하면 돼요.

> - 내가 필요한 데이터 묶음을 직접 정의해요
> - 그 묶음을 변수처럼 써요
> 

---

## 19-3. 구조체 정의 기본 형태

가장 기본 모양은 이거예요.

```c
struct Student {
    char name[20];
    int id;
    int score;
};

```

여기서 포인트는 이거예요.

여기서 포인트는 이거예요.

> - Student는 "학생 데이터 묶음"의 설계도예요
> - 실제 값은 아직 없어요
> - 이 설계도로 변수를 만들어야 진짜로 쓸 수 있어요
> 

---

## 19-4. 구조체 변수 만들기

정의한 구조체로 변수를 만들면 이렇게 돼요.

```c
struct Student s;

```

이제 `s`는 이런 걸 한 번에 들고 있어요.

이제 `s`는 이런 걸 한 번에 들고 있어요.

> - `s.name`
> - `s.id`
> - `s.score`
> 

---

## 19-5. 구조체 멤버 접근: `.` (점)

구조체 안의 값은 `.`로 접근해요.

```c
#include <stdio.h>

struct Student {
    char name[20];
    int id;
    int score;
};

int main(void) {
    struct Student s;

    s.id = 20260001;
    s.score = 95;

    printf("%d\n", s.id);
    printf("%d\n", s.score);

    return 0;
}

```

포인트는 이거예요.

포인트는 이거예요.

> - 구조체 변수 s의 내부 칸을 찍어서 접근해요
> - 배열 인덱스랑 비슷하게 "칸을 고른다"는 감각이에요
> 

---

## 19-6. 선언과 동시에 초기화도 가능해요

배열처럼, 구조체도 한 번에 초기화할 수 있어요.

```c
struct Student s = {"minhyuk", 20260001, 95};

```

초반엔 이 느낌만 잡으면 돼요.

초반엔 이 느낌만 잡으면 돼요.

> - 순서대로 들어가요
> - 정의한 멤버 순서랑 맞춰야 해요
> 

---

## 19-7. 구조체 배열: 학생 여러 명이면 이게 진짜 편해요

학생이 한 명이면 변수 하나면 되는데

여러 명이면 배열처럼 묶고 싶어지죠.

그럴 때 구조체 배열을 씁니다.

```c
#include <stdio.h>

struct Student {
    char name[20];
    int id;
    int score;
};

int main(void) {
    struct Student a[3];

    a[0].id = 1;
    a[1].id = 2;
    a[2].id = 3;

    printf("%d\n", a[1].id); // 2
    return 0;
}

```

포인트는 이거예요.

포인트는 이거예요.

> - `a[i]`는 i번째 학생(구조체 하나)이에요
> - 그 안의 멤버는 `.id`, `.score`로 접근해요
> - 즉 `a[i].score` 같은 형태가 기본이에요
> 

---

## 19-8. 구조체를 함수로 넘기기 (입문용 감각)

구조체도 함수에 넘길 수 있어요.

초반엔 이렇게만 기억하면 충분해요.

초반엔 이렇게만 기억하면 충분해요.

> - 구조체를 값으로 넘기면 "복사"될 수 있어요
> - 바깥 값을 바꾸려면 "주소"를 넘기는 게 편해요
> 

---

## 19-9. 구조체 포인터와 `>` (이건 많이 보게 돼요)

구조체의 주소를 받으면 포인터가 되죠.

```c
struct Student *p = &s;

```

이때 멤버 접근은 `->`를 써요.

이때 멤버 접근은 `->`를 써요.

> - p->id 는 (*p).id 랑 같은 뜻이에요
> 

---
예시.

```c
#include <stdio.h>

struct Student {
    char name[20];
    int id;
    int score;
};

void setScore(struct Student *p, int score) {
    p->score = score;
}

int main(void) {
    struct Student s = {"kim", 1, 0};

    setScore(&s, 90);
    printf("%d\n", s.score);

    return 0;
}

```

포인트는 이거예요.

> - 구조체를 함수에서 바꾸고 싶으면 주소를 넘겨요
> - `->`는 “구조체 포인터 전용 점(.)” 같은 느낌이에요
> 

---

## 19-10. 직접 쳐볼 예시: 입력받아서 출력하기

입문 톤으로 “이 정도면 구조체 쓴다” 느낌 내기 좋은 예시예요.

```c
#include <stdio.h>

struct Student {
    char name[20];
    int id;
    int score;
};

int main(void) {
    struct Student s;

    scanf("%s %d %d", s.name, &s.id, &s.score);
    printf("%s %d %d\n", s.name, s.id, s.score);

    return 0;
}

```

포인트는 이거예요.

> - `s.name`은 문자열 배열이라 `&` 안 붙는 경우가 많아요
> - `s.id`, `s.score`는 int라서 `&`가 붙어요
> 

---

## 19-11. 자주 하는 실수 모음

> - 구조체 멤버에 접근할 때 `.`, `->`를 섞어 씀
> - 구조체 배열에서 `a[i].score` 대신 `a.score[i]` 같은 식으로 헷갈림
> - `scanf`에서 `&` 붙여야 할 곳과 아닌 곳을 반대로 함
> - 구조체 포인터인데 `p.id`처럼 점(.)을 써버림 (이때는 `p->id`)
> 

---

## 19-12. 미션

아래 중 두 개만 해도 충분해요.

- 학생 3명을 입력받아서, 점수 평균을 출력하기 (구조체 배열 + 반복문)
- 최고 점수 학생의 이름을 출력하기 (max 패턴을 구조체에 적용)
- `setScore(struct Student *p, int score)` 같은 함수를 하나 더 만들어서 구조체 값 바꾸기 연습하기


---

## 19-13. 다음 장

다음 장에서는 구조체랑 같이 자주 나오는 개념을 이어갈 거예요.

> - 구조체를 함수로 넘길 때 "복사 vs 주소" 감각 더 잡기
> - 여러 데이터를 만들고 지우고 싶을 때 필요한 것(동적 메모리의 맛보기)
> - 그리고 C에서 자주 쓰는 "typedef"로 구조체를 더 편하게 쓰는 방법
> 

(20장은 이 흐름으로 자연스럽게 가면 딱 좋아요.)

---

# 20장. 동적 메모리 — 필요할 때 만들고, 다 쓰면 지우기

## 20-1. 왜 이게 필요하냐면

배열은 만들 때 크기를 박아야 했죠.

> - 입력이 몇 개인지 모를 때
> - 프로그램 실행 중에 크기가 바뀔 때
> - 큰 데이터를 "필요한 만큼만" 쓰고 싶을 때
> 

이럴 때는 "실행 중에 메모리를 빌려 쓰는 방법"이 필요해요.

처음엔 "왜 이렇게까지 해야 하지?" 싶을 수 있는데

지금은 "이런 게 있구나" 정도만 알고 가도 충분해요.

실전에서 필요할 때 다시 보면 돼요.

---

## 20-2. 준비물: `stdlib.h`

동적 메모리 함수는 보통 여기 있어요.

```c
#include <stdlib.h>

```

---

## 20-3. 핵심 2개만 잡기: `malloc` / `free`

이 두 함수만 기억하면 돼요.

> - `malloc` : 메모리 빌리기 (새로 만들기)
> - `free` : 메모리 반납하기 (다 쓰면 지우기)
> 

`malloc`이 돌려주는 건 “주소”예요. 그래서 포인터에 받아요.

---

## 20-4. 가장 기본 형태

정수 5개짜리 공간을 실행 중에 만들기:

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int *a = (int*)malloc(sizeof(int) * 5);
    if (a == NULL) return 0; // 빌리기 실패

    a[0] = 10;
    a[1] = 20;

    printf("%d\n", a[0]);
    printf("%d\n", a[1]);

    free(a);  // 반납
    return 0;
}

```

코드 설명은 이거예요.

> - `sizeof(int) * 5` 만큼의 공간을 빌려요
> - 결과는 주소라서 `int *a`에 담아요
> - 배열처럼 `a[i]`로 써요
> - 마지막에 `free(a)`로 반납해요
> 

---

## 20-5. `sizeof`는 “몇 바이트냐” 계산기

이걸 외우면 편해요.

이걸 외우면 편해요.

> - `sizeof(int)` : int 한 칸 크기
> - `sizeof(double)` : double 한 칸 크기
> - "칸 크기 × 칸 개수" 만큼 빌려요
> 

---

## 20-6. 입력 n개를 받아서 “n칸짜리 배열” 만들기

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int n;
    scanf("%d", &n);

    int *a = (int*)malloc(sizeof(int) * n);
    if (a == NULL) return 0;

    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }

    long long sum = 0;
    for (int i = 0; i < n; i++) {
        sum += a[i];
    }

    printf("%lld\n", sum);

    free(a);
    return 0;
}

```

이 패턴은 진짜 자주 써요.

> - n을 먼저 입력받아요
> - n칸을 빌려요
> - 배열 문제 패턴(입력→처리→출력)을 그대로 써요
> 

---

## 20-7. `realloc` — 크기 바꾸기 (맛보기)

“더 필요해졌을 때 늘리기” 같은 상황에서 써요.

```c
int *b = (int*)realloc(a, sizeof(int) * newN);
if (b == NULL) {
    // 실패하면 원래 a는 그대로일 수 있음 (그래서 b로 받는 습관)
} else {
    a = b;
}

```

여기서 주의할 점이 있어요.

> - 기존 포인터를 바로 덮어쓰지 말고, 새 포인터로 받아서 성공을 확인해야 해요
> - 실패하면 `NULL`이 나올 수 있어요
> 

---

## 20-8. 동적 메모리에서 제일 많이 터지는 실수

이 실수들은 꼭 조심하세요.

> - `malloc` 했는데 `free` 안 해서 메모리 누수
> - `free` 한 다음에 또 쓰는 실수 (반납 후 사용)
> - `free`를 두 번 하는 실수 (double free)
> - `malloc` 결과가 `NULL`인데도 그대로 쓰는 실수
> - "칸 개수"가 아니라 "바이트"를 빌려야 한다는 걸 잊는 실수 (`malloc(n)` 이 아니라 `malloc(sizeof(int)*n)`)
> 

---

## 20-9. 직접 쳐볼 예시: 최댓값 구하기 (n개)

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int n;
    scanf("%d", &n);

    int *a = (int*)malloc(sizeof(int) * n);
    if (a == NULL) return 0;

    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    int mx = a[0];
    for (int i = 1; i < n; i++) {
        if (a[i] > mx) mx = a[i];
    }

    printf("%d\n", mx);

    free(a);
    return 0;
}

```

---

## 20-10. 미션

아래 중 두 개만 해도 충분해요.

- n을 입력받고 정수 n개를 동적 배열에 저장한 뒤, 최솟값 출력하기
- n을 입력받고 정수 n개를 저장한 뒤, 짝수의 개수 출력하기
- n을 입력받고 정수 n개를 저장한 뒤, 거꾸로 출력하기


---

## 20-11. 다음 장

다음 장에서는 이런 게 나와요.

> - "데이터를 메모리에만 두지 말고 파일로 저장하기"
> - "저장한 걸 다시 읽어오기"
> 

이 흐름으로 **파일 입출력**으로 넘어가면 자연스럽습니다.

---

# 21장. 파일 입출력 — 결과를 저장하고 다시 불러오기

## 21-1. 왜 이게 필요하냐면

지금까지 프로그램은 실행하면 끝이었죠.

지금까지 프로그램은 실행하면 끝이었죠.

> - 실행할 때 입력하고
> - 화면에 출력하고
> - 프로그램이 끝나면 다 사라져요
> 

근데 현실에서는 이런 걸 하고 싶어져요.

근데 현실에서는 이런 걸 하고 싶어져요.

> - 결과를 파일로 저장하고 싶다
> - 다음에 다시 실행해도 데이터를 그대로 쓰고 싶다
> - 입력을 매번 치기 귀찮다 (파일에서 읽고 싶다)
> 

---

## 21-2. 준비물: `stdio.h` 하나면 충분해요

파일 입출력도 결국 “입출력”이라서 `stdio.h`에 있어요.

```c
#include <stdio.h>

```

---

## 21-3. 파일은 보통 이 흐름이에요

파일 작업은 보통 이 순서예요.

> - 파일 열기 (`fopen`)
> - 읽기/쓰기 (`fprintf`, `fscanf`, `fgets`, `fputs` 등)
> - 파일 닫기 (`fclose`)
> 

이 순서만 안 깨지면, 절반은 끝이에요.

---

## 21-4. 파일 포인터 `FILE *fp`

파일을 열면 “파일을 가리키는 손잡이”를 하나 받아요.

파일을 열면 "파일을 가리키는 손잡이"를 하나 받아요.

> - 그게 `FILE *`예요
> - 보통 이름은 `fp`로 써요
> - `NULL`이면 열기 실패예요
> 

---

## 21-5. 파일 열기: `fopen("파일명", "모드")`

모드는 일단 2개만 잡아요.

모드는 일단 2개만 잡아요.

> - `"r"` : 읽기 모드 (read)
> - `"w"` : 쓰기 모드 (write)
> - 파일이 없으면 새로 만들고
> - 파일이 있으면 내용이 덮어써져요
> 

```c
FILE *fp = fopen("data.txt", "w");
if (fp == NULL) {
    return 0;
}

```

---

## 21-6. 파일에 쓰기: `fprintf`

`printf`가 화면이면, `fprintf`는 파일이라고 생각하면 돼요.

```c
fprintf(fp, "%d %d\n", a, b);

```

---

## 21-7. 파일에서 읽기: `fscanf`

`scanf`가 키보드면, `fscanf`는 파일이라고 생각하면 돼요.

```c
fscanf(fp, "%d", &x);

```

---

## 21-8. 파일 닫기: `fclose`

다 썼으면 꼭 닫아요.

다 썼으면 꼭 닫아요.

> - 쓰기 버퍼가 남아있으면 반영이 안 될 수 있어요
> - 파일 자원을 반납해야 해요
> 

```c
fclose(fp);

```

---

## 21-9. 예시 1: 정수 5개를 파일에 저장하기

```c
#include <stdio.h>

int main(void) {
    FILE *fp = fopen("nums.txt", "w");
    if (fp == NULL) return 0;

    for (int i = 0; i < 5; i++) {
        int x;
        scanf("%d", &x);
        fprintf(fp, "%d\n", x);
    }

    fclose(fp);
    return 0;
}

```

동작은 간단해요.

> - 키보드로 입력 받고
> - 파일에 한 줄씩 저장해요
> 

---

## 21-10. 예시 2: 파일에서 정수 5개를 읽어서 합 구하기

```c
#include <stdio.h>

int main(void) {
    FILE *fp = fopen("nums.txt", "r");
    if (fp == NULL) return 0;

    int sum = 0;
    for (int i = 0; i < 5; i++) {
        int x;
        fscanf(fp, "%d", &x);
        sum += x;
    }

    printf("%d\n", sum);

    fclose(fp);
    return 0;
}

```

읽기도 비슷해요.

> - 파일에서 읽어서
> - 기존 배열 문제처럼 처리해요
> 

---

## 21-11. 문자열 한 줄을 파일에서 읽기: `fgets`도 그대로 쓸 수 있어요

`stdin` 대신 파일 포인터를 넣으면 돼요.

```c
char line[100];
fgets(line, 100, fp);

```

---

## 21-12. 파일 입출력에서 자주 터지는 실수

이 실수들은 조심해야 해요.

> - 파일을 "r"로 열었는데 파일이 없어서 `NULL`
> - "w"로 열었는데 기존 내용이 날아감(덮어쓰기)
> - `fopen` 실패 체크 안 해서 `fp`가 `NULL`인데 읽고/쓰기 시도
> - `fclose`를 안 해서 저장이 덜 되거나 자원 누수
> - `fscanf`가 실패했는데도 계속 읽는다고 가정함
> 

---

## 21-13. 입력이 끝났는지 확인하는 감각 (맛보기)

파일에서 읽을 때는 “더 이상 읽을 게 없을 수도” 있어요.

그래서 이런 식으로 체크하는 패턴이 있어요.

```c
int x;
while (fscanf(fp, "%d", &x) == 1) {
    // 읽기 성공했을 때만 실행
}

```

이 코드는 이런 뜻이에요.

> - `fscanf`가 1을 반환하면 정수 1개 읽기 성공
> - 실패하면 반복 종료
> 

---

## 21-14. 미션

아래 내용으로 직접 연습해보세요.

- 정수 n개를 입력받아 `nums.txt`에 저장하기 (한 줄에 하나씩)
- `nums.txt`를 다시 열어서 모든 숫자의 합 출력하기
- `nums.txt`를 읽어서 최댓값 출력하기 (while + fscanf 패턴 써보기)


---

## 21-15. 다음 장

파일까지 하면 “저장/복원”이 되죠.

여기까지 오면 C의 핵심 개념은 거의 다 본 거예요.

다음 장은 마무리 장이에요.

> - 지금까지 배운 걸 정리하고
> - 다음에 뭘 하면 좋을지 이야기할게요
> 

---

# 22장. 마무리 — 이제 “C가 무섭지 않은 상태”가 됐어요

## 22-1. 여기까지 왔으면, 사실 이미 게임 끝났어요



> - `;` 하나 빠져도 에러
> - 괄호 어디 닫는지도 모르겠고
> - `scanf`에 `&` 붙이라니까 그냥 외웠고
> - 배열 나오면서 "이거부터 어려운데?" 싶고
> - 문자열은 `\0` 때문에 갑자기 이상한 세계 같고
> - 포인터는 기호가 너무 많아서 일단 무서움
> 



> - 코드가 "왜 이렇게 생겼는지" 대충 감이 있고
> - 에러가 나도 "어디부터 봐야 하는지" 감이 있고
> - 무엇보다, 대충이 아니라 직접 만들어본 게 있다
> 

이게 진짜 커요.

---

## 22-2. 이 웹사이트 기준으로 “기초”는 어디까지냐?



> - 변수 / 연산 / 입출력
> - 조건문 / 반복문
> - 배열 + 배열로 문제 풀기
> - 문자열(= char 배열 + `\0`)
> - 함수(코드 쪼개기)
> - 값/주소 전달(왜 어떤 건 바뀌고 어떤 건 안 바뀌는지)
> - 포인터(주소 문법)
> - 배열-포인터 관계(배열이 왜 주소처럼 보이는지)
> - 구조체(데이터를 한 덩어리로 묶기)
> 

이 정도면 **“C 문법 때문에 겁먹는 단계”는 이미 지나갔어요.**

---

## 22-3. 근데 여기서 갑자기 실력이 늘지 않는 느낌이 들 수 있어요



> - "내용은 이해한 것 같은데..."
> - "막상 문제 보니까 손이 안 움직이는데?"
> - "내가 진짜 안다고 말할 수 있나?"
> 

이거 정상이에요.



> - 문제를 읽고
> - 필요한 변수를 잡고
> - 반복문/조건을 조합해서
> - 내 머리로 설계하는 단계
> 

로 넘어가기 때문이에요.

즉, **공부 → 실전**으로 넘어가는 구간이라 그래요.

---

## 22-4. 그래서 내가 추천하는 “마무리 루틴”이 있어요



> - 이 사이트를 처음부터 2~3번 더 훑어보세요
> - 대신 처음처럼 꼼꼼히 보지 말고, 빠르게 훑는 느낌으로
> - "아 이거 이때 나왔지" 감각만 남겨도 충분해요
> - 두 번째부터는 특히 코드만 보고도 무슨 장인지 떠올리는 상태가 목표예요
> 



> - 반드시 알고리즘 문제도 풀어보시는 것을 추천드릴게요!
> - 이건 "공부를 확인하는 용도"가 아니라
> - C가 몸에 붙는 과정이라서 그래요
> 



> - 배열 합/최댓값/최솟값/개수
> - 문자열 길이/공백 개수/대소문자 변환
> - 구조체로 학생 정보 정렬 "비슷한 거" (정렬 자체는 다음 단계지만, 비교 기준 잡는 감각이 중요)
> 

---

## 22-5. 다음에 뭘 하면 “C가 더 강해지냐?”

여기서부터는 선택지가 몇 개 있어요.

> - 파일 입출력 (`fopen`, `fprintf`, `fscanf`)
> - 동적 메모리 (`malloc`, `free`)
> - 구조체 + 포인터 조합 (연결 리스트 같은 자료구조로 이어짐)
> - 정렬/탐색 같은 알고리즘 패턴 (진짜 실력 구간)
> 

근데 솔직히 말하면,

> - 지금 당장 뭘 더 배우기 전에
> - 배열/문자열/함수 문제를 조금만 더 풀면
> - 그 다음 단계가 “안 무섭게” 들어가져요
> 

---

## 22-6. 마지막으로, 진짜로 수고했어요

여기까지 왔다는 건요,

> - 그냥 “설명 들은 사람”이 아니라
> - 손으로 한 번이라도 만들어본 사람이라는 뜻이에요
> 

C는 원래 초반에 겁을 주는 언어인데

지금은 그 겁의 대부분을 이미 깨버린 상태예요.

> - 다시 한 번 말하지만
> - 처음부터 몇 번 더 보는 걸 추천드리고,
> - 반드시 알고리즘 문제도 풀어보시는 것을 추천드릴게요!
> 

이제부터는 “추가 학습”이 아니라

> “익숙해지는 과정”만 남았어요.
>